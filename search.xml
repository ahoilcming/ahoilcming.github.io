<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git全面教程——使用！！！</title>
      <link href="/2023/08/30/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/08/30/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>现在，运行<code>git status</code>命令看看结果：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add distributed&quot;</span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p></li><li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p></li></ul><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>然后尝试提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/0.jpg" alt="1"></p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──▶ ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──▶ ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>现在总结一下：</p><ul><li><p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p></li><li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p></li><li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p></li></ul><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>先来看名词解释。</p><h2 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h2><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/1.jpg" alt="1"></p><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/2.jpg" alt="2"></p><p>分支和<code>HEAD</code>的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><ul><li><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p></li><li><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p></li></ul><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   LICENSE</span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/3.jpg" alt="5"></p><p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/5.jpg" alt="6"></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p><p>没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。</p><h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure><p>然后，添加：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>然后，再修改readme.txt：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;git tracks changes&quot;</span><br><span class="line">[master 519219b] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>提交后，再看看状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>咦，怎么第二次的修改没有被提交？</p><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>可见，第二次修改确实没有被提交。</p><p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><p>好，现在，把第二次修改提交了，然后开始小结。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mreadme.txt</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>整个世界终于清静了！</p><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>现在，文件就从版本库中被删除了。</p><p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习技能 </category>
          
          <category> git全面教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git全面教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系架构知识点总结</title>
      <link href="/2023/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-yingjian/"/>
      <url>/2023/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-yingjian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-硬件基础"><a href="#1-硬件基础" class="headerlink" title="1.硬件基础"></a>1.硬件基础</h2><h3 id="1-1-CPU、MPU、MCU、SOC、SOPC联系与差别？"><a href="#1-1-CPU、MPU、MCU、SOC、SOPC联系与差别？" class="headerlink" title="1.1 CPU、MPU、MCU、SOC、SOPC联系与差别？"></a>1.1 CPU、MPU、MCU、SOC、SOPC联系与差别？</h3><ol><li><p><strong>CPU（Central Processing Unit）</strong></p><p> CPU是一台计算机的<strong>运算核心和控制核心</strong>。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。差不多所有的CPU的运作原理可分为四个阶段：提取（Fetch）、解码（Decode）、执行（Execute）和写回（Writeback）。CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。</p></li><li><p><strong>MPU(Micro Processor Unit)</strong></p><p> MPU叫<strong>微处理器</strong>（不是微控制器），通常代表一个<strong>功能强大的CPU</strong>（暂且理解为<strong>增强版的CPU</strong>吧）,但不是为任何已有的特定计算目的而设计的芯片。这种芯片往往是个人计算机和高端工作站的核心CPU。最常见的微处理器是Motorola的68K系列和Intel的X86系列。</p></li><li><p><strong>MCU(Micro Control Unit)</strong></p><p> MCU叫微控制器，是指随着大规模集成电路的出现及其发展，将<strong>计算机的CPU、RAM、ROM、定时计数器和多种I/O接口集成在一片芯片上</strong>，形成芯片级的芯片，比如51，avr这些芯片，内部<strong>除了CPU外还有RAM,ROM,可以直接加简单的外围器件</strong>（电阻，电容）就可以运行代码了，而MPU如x86，arm这些就不能直接放代码了，它只不过是增强版的CPU，所以得添加RAM,ROM。MCUMPU最主要的区别就睡能否直接运行代码。MCU有内部的RAMROM，而MPU是增强版的CPU，需要添加外部RAMROM才可以运行代码。</p></li><li><p><strong>SOC（Systemon Chip）</strong></p><p> SOC指的是片上系统，MCU只是<strong>芯片级</strong>的芯片，而<strong>SOC是系统级的芯片</strong>，它既MCU（51，avr）那样有内置RAM,ROM同时又像MPU（arm）那样强大的，不单单是放简单的代码，可以放系统级的代码，也就是说可以<strong>运行操作系统</strong>（将就认为是MCU集成化与MPU强处理力各优点二合一）。</p></li><li><p><strong>SOPC（System On a Programmable Chip）</strong></p><p> SOPC可编程片上系统（FPGA就是其中一种），上面4点的硬件配置是固化的，就是说51单片机就是51单片机，不能变为avr，而avr就是avr不是51单片机，他们的硬件是一次性掩膜成型的，能改的就是软件配置，说白点就是改代码，本来是跑流水灯的，改下代码，变成数码管，而SOPC则是<strong>硬件配置，软件配置都可以修改</strong>，软件配置跟上面一样，没什么好说的，至于硬件，是可以自己构建的也就是说这个芯片是自己构造出来的，<strong>这颗芯片我们叫“白片”</strong>，什么芯片都不是，把<strong>硬件配置信息下载进去了，他就是相应的芯片了</strong>，可以让他变成51，也可以是avr，甚至arm，同时SOPC是在SOC基础上来的，所以他也是系统级的芯片，所以记得当把他变成arm时还得加外围ROM，RAM之类的，不然就是MPU了。</p></li></ol><h3 id="1-2-交叉编译器是什么？为什么需要交叉编译器？"><a href="#1-2-交叉编译器是什么？为什么需要交叉编译器？" class="headerlink" title="1.2 交叉编译器是什么？为什么需要交叉编译器？"></a>1.2 交叉编译器是什么？为什么需要交叉编译器？</h3><ol><li><p><strong>在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码</strong>，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码。</p></li><li><p>这里需要注意的是所谓平台，实际上包含两个概念：<strong>体系结构（Architecture）、操作系统（Operating System）</strong>。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和WindowsNT for x86操作系统的简称。</p></li><li><p>有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又<strong>需要这个编译器的某些特征</strong>；有时是因为目的平台上的<strong>资源贫乏</strong>，无法运行我们所需要编译器；有时又是因为目的<strong>平台还没有建立</strong>，连操作系统都没有，根本谈不上运行什么编译器。</p></li></ol><h3 id="1-3-描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？"><a href="#1-3-描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？" class="headerlink" title="1.3 描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？"></a>1.3 描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？</h3><p>基于RAM</p><ol><li><p>需要把硬盘和其他介质的代码先加载到ram中，加载过程中一般有<strong>重定位</strong>的操作。</p></li><li><p><strong>速度比基于ROM的快，可用RAM比基于ROM的少</strong>，因为所有的代码，数据都必须存放在RAM中。</p></li></ol><p>基于ROM</p><ol><li><p><strong>速度较基于RAM的慢</strong>，因为会有一个把变量，部分代码等从存储器（硬盘，flash）搬移到RAM的过程。</p></li><li><p><strong>可用RAM资源比基于RAM的多</strong></p></li></ol><h2 id="2-ARM处理器"><a href="#2-ARM处理器" class="headerlink" title="2.ARM处理器"></a>2.ARM处理器</h2><h3 id="2-1-什么是哈佛结构和冯诺依曼结构？"><a href="#2-1-什么是哈佛结构和冯诺依曼结构？" class="headerlink" title="2.1 什么是哈佛结构和冯诺依曼结构？"></a>2.1 什么是哈佛结构和冯诺依曼结构？</h3><p>定义：冯诺依曼结构釆用指令和数据<strong>统一编址</strong>，使用<strong>同条总线</strong>传输，CPU读取指令和数据的操作<strong>无法重叠</strong>。哈佛结构釆用指令和数据<strong>独立编址</strong>，使用<strong>两条独立的总线传输</strong>，CPU读取指令和数据的操作<strong>可以重叠</strong>。</p><p>利弊：冯诺依曼结构主要用于<strong>通用计算机领域</strong>，需要对存储器中的代码和数据频繁的进行修改，统一编址有利于<strong>节约资源</strong>。哈佛结构主要用于<strong>嵌入式计算机</strong>，程序固化在硬件中，有较高的<strong>可靠性、运算速度和较大的吞吐量</strong>。</p><h3 id="2-2-什么是ARM流水线技术？"><a href="#2-2-什么是ARM流水线技术？" class="headerlink" title="2.2 什么是ARM流水线技术？"></a>2.2 什么是ARM流水线技术？</h3><ol><li><p>流水线技术通过<strong>多个功能部件并行</strong>工作来<strong>缩短程序执行时间</strong>，提高处理器核的<strong>效率和吞吐率</strong>，从而成为微处理器设计中最为重要的技术之一。ARM7处理器核使用了典型<strong>三级流水线的冯·诺伊曼结构</strong>，ARM9系列则采用了基于<strong>五级流水线的哈佛结构</strong>。通过增加流水线级数简化了流水线各级的逻辑，进一步提高了处理器的性能。</p></li><li><p>PC代表<strong>程序计数器</strong>，流水线使用三个阶段，因此指令分为三个阶段执行：1.<strong>取指</strong>（从存储器装载一条指令）；2.<strong>译码</strong>（识别将要被执行的指令）；3.<strong>执行</strong>（处理指令并将结果写回寄存器）。而<strong>R15（PC）总是指向“正在取指”的指令</strong>，而不是指向“正在执行”的指令或正在“译码”的指令。一般来说，人们习惯性约定将“正在执行的指令作为参考点”，称之为当前第一条指令，因此<strong>PC总是指向第三条指令</strong>。当ARM状态时，每条指令为4字节长，所以PC始终指向该指令地址加8字节的地址，即：<strong>PC值=当前程序执行位置+8</strong>；</p></li><li><p>ARM指令是三级流水线，取指，译指，执行，同时执行的，现在PC指向的是正在取指的地址（下一条指令），那么<strong>cpu正在译指的指令地址是PC-4</strong>（假设在ARM状态下，一个指令占4个字节），<strong>cpu正在执行的指令地址是PC-8</strong>，也就是说PC所指向的地址和现在所执行的指令地址相差8。当突然发生中断的时候，保存的是PC的地址（PC-8+4=<strong>PC-4</strong>下一条指令的地址）。这样你就知道了，<strong>如果返回的时候返回PC，那么中间就有一个指令没有执行</strong>，所以用<code>SUB pc lr-irq</code></p><p> <img src="https://tuchuang.voooe.cn/images/2023/03/05/ARM7025050fed1ab1a6.png" alt="https://tuchuang.voooe.cn/images/2023/03/05/ARM7025050fed1ab1a6.png"></p></li></ol><h3 id="2-3-ARM有几种工作模式？"><a href="#2-3-ARM有几种工作模式？" class="headerlink" title="2.3 ARM有几种工作模式？"></a>2.3 ARM有几种工作模式？</h3><ol><li><p><strong>用户模式(USR)</strong></p><p> 用户模式是用户程序的工作模式，它运行在操作系统的用户态，它<strong>没有权限去操作其它硬件资源</strong>，只能执行处理自己的数据，也<strong>不能切换到其它模式下</strong>，要想访问硬件资源或切换到其它模式只能通过<strong>软中断或产生异常</strong>。</p></li><li><p><strong>系统模式(SYS)</strong></p><p> 系统模式是<strong>特权模式</strong>，不受用户模式的限制。用户模式和系统模式共用一套寄存器，操作系统在该模式下可以方便的访问用户模式的寄存器，而且操作系统的一些特权任务可以使用这个模式<strong>访问一些受控的资源</strong>。</p><blockquote><p>说明：用户模式与系统模式两者<strong>使用相同的寄存器</strong>，都没有SPSR（Saved Program Statement Register，已保存程序状态寄存器），但系统模式比用户模式有更高的权限，可以访问所有系统资源。</p></blockquote></li><li><p><strong>一般中断模式(IRQ)</strong></p><p> 一般中断模式也叫普通中断模式，用于处理一般的中断请求，通常在硬件<strong>产生中断信号之后自动进入</strong>该模式，该模式为特权模式，可以<strong>自由访问系统硬件资源</strong>。</p></li><li><p><strong>快速中断模式(FIQ)</strong></p><p> 快速中断模式是相对一般中断模式而言的，它是用来处理<strong>对时间要求比较紧急的中断请求</strong>，主要用于高速数据传输及通道处理中。（快中断有许多（R8~R14）自己的专用寄存器，发生中断时，使用自己的寄存器就避免了保存和恢复某些寄存器。如果异常中断处理程序中使用它自己的物理寄存器之外的其他寄存器，异常中断处理程序必须保存和恢复这些寄存器）</p></li><li><p><strong>管理模式（SVC）</strong></p><p> 管理模式是<strong>CPU上电后默认模式</strong>，因此，在该模式下主要用来做<strong>系统的初始化</strong>，软中断处理也在该模式下。当用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式。</p><blockquote><p>说明：系统复位或开机、软中断时进入到SVC模式下。</p></blockquote></li><li><p><strong>终止模式(ABT)</strong></p><p> 中止模式用于支持虚拟内存或存储器保护，当用户程序<strong>访问非法地址，没有权限读取的内存地址</strong>时，会进入该模式，linux下编程时经常出现的segment fault通常都是在该模式下抛出返回的。</p></li><li><p><strong>未定义模式(UND)</strong></p><p> 未定义模式用于支持硬件协处理器的软件仿真，CPU在指令的译码阶段不能识别该指令操作时，会进入未定义模式。</p></li></ol><p><strong>注意：</strong></p><ol><li><p><strong>除了用户模式外</strong>，其它6种模式称为特权模式。所谓特权模式，即具有如下权利：</p><p> a.MRS（把状态寄存器的内容放到通用寄存器）；</p><p> b.MSR（把通用寄存器的内容放到状态寄存器中）。</p><p> 由于状态寄存器中的内容不能够改变，因此，要先把内容复制到通用寄存器中，然后修改通用寄存器中的内容，再把通用寄存器中的内容复制给状态寄存器中，即可完成“修改状态寄存器”的任务。</p></li><li><p>剩下的六种模式中<strong>除去系统模式</strong>外，统称为异常模式。</p></li></ol><h3 id="2-4-Arm有多少32位寄存器？"><a href="#2-4-Arm有多少32位寄存器？" class="headerlink" title="2.4 Arm有多少32位寄存器？"></a>2.4 Arm有多少32位寄存器？</h3><p>ARM处理器共有37个寄存器。它包含<strong>31个通用寄存器和6个状态寄存器</strong>。</p><h3 id="2-5-ARM指令集分为几类？"><a href="#2-5-ARM指令集分为几类？" class="headerlink" title="2.5 ARM指令集分为几类？"></a>2.5 ARM指令集分为几类？</h3><p>2类，分别为Thumb指令集，ARM指令集。<strong>ARM指令长度为32位，Thumb指令长度为16位</strong>。这种特点<br>使得ARM既能执行16位指令，又能执行32位指令，从而增强了ARM内核的功能。</p><h3 id="2-6-通用寄存器包括R0～R15，可以分为具体哪三类？"><a href="#2-6-通用寄存器包括R0～R15，可以分为具体哪三类？" class="headerlink" title="2.6 通用寄存器包括R0～R15，可以分为具体哪三类？"></a>2.6 通用寄存器包括R0～R15，可以分为具体哪三类？</h3><p>通用寄存器包括R0-R15，可以分为3类：</p><ol><li><p><strong>未分组寄存器R0-R7</strong></p><p> 在所有运行模式下，未分组寄存器都指向<strong>同一个物理寄存器</strong>，他们未被系统用作特殊的用途。因此在中断或<strong>异常处理</strong>进行异常模式转换时，由于不同的处理器运行模式均使用相同的物理寄存器，所以<strong>可能造成寄存器中数据的破坏</strong>。</p></li><li><p><strong>分组寄存器R8-R14</strong></p><p> 对于分组寄存器，他们每次所访问的物理寄存器都<strong>与当前的处理器运行模式相关</strong>。R13常用作存放堆栈指针，用户也可以使用其他寄存器存放堆栈指针，但在Thumb指令集下，某些指令强制要求使用R13存放堆栈指针。R14称为链接寄存器（LR，Link Register），当执行子程序时，R14可得到R15（PC）的备份，执行完子程序后，又将R14的值复制回PC，即使用R14保存返回地址。</p></li><li><p><strong>程序计数器PC（R15）</strong></p><p> 寄存器R15用作程序计数器（PC），在ARM状态下，位[1:0]为0，位[31:2]用于保存PC；在Thumb状态下,位[0]为0，位[31:1]用于保存PC。</p></li></ol><p>ARM系统中，在函数调用的时候，参数是通过哪种方式传递的？</p><p>当参数小于等于4的时候是通过<strong>r0-r3</strong>寄存器来进行传递的，当参数大于4的时候是通过<strong>压栈</strong>的方式进行传递。</p><h3 id="2-7-ARM处理器有几种工作状态？"><a href="#2-7-ARM处理器有几种工作状态？" class="headerlink" title="2.7 ARM处理器有几种工作状态？"></a>2.7 ARM处理器有几种工作状态？</h3><p>从编程的角度来看，ARM微处理器的工作状态一般ARM和Thumb有两种，并可在两种状态之间切换。</p><ol><li><p>ARM状态：此时处理器执行32位的字对齐ARM指令，绝大部分工作在此状态。</p></li><li><p>Thumb状态：此时处理器执行16位的半字对齐的Thumb指令。</p></li></ol><h3 id="2-8-ARM协处理器指令包括哪3类，请描述它们的功能？"><a href="#2-8-ARM协处理器指令包括哪3类，请描述它们的功能？" class="headerlink" title="2.8 ARM协处理器指令包括哪3类，请描述它们的功能？"></a>2.8 ARM协处理器指令包括哪3类，请描述它们的功能？</h3><ol><li><p>用于ARM处理器<strong>初始化</strong>ARM协处理器的数据处理操作。</p></li><li><p>用于ARM处理器的<strong>寄存器和ARM协处理器</strong>的寄存器间的<strong>数据传送</strong>操作。</p></li><li><p>用于在ARM协处理器的<strong>寄存器和内存单元</strong>之间传送数据。</p></li></ol><h3 id="2-9-什么是PLL（锁相环）？"><a href="#2-9-什么是PLL（锁相环）？" class="headerlink" title="2.9 什么是PLL（锁相环）？"></a>2.9 什么是PLL（锁相环）？</h3><p>简单来说，输入时钟的存在是作为“参考源”。锁相环<strong>不是为了单纯产生同频同相信号，而是一般集成进某种“频率综合电路”，产生一个不同频，但锁相的信号</strong>。有点绕，打个比方：某参考晶振10Mhz，频率综合器A使用该参考源产生了900Mhz时钟，而频率综合器B产生了1Ghz时钟。虽然两路频率不同，但<strong>由于使用的通一个参考源，他们俩仍然是同源信号</strong>。相反，如果不同源，那么即便同频他们也不可能一致，因为世界上没有两个钟能做到完全一样，总有微弱的频差，导致相位飘移。在很多现实应用中有要求同源时钟的场合，所以，锁相环被广泛应用。锁相环的另外一项衍生应用是<strong>相干解调</strong>。</p><h2 id="3-中断与异常"><a href="#3-中断与异常" class="headerlink" title="3.中断与异常"></a>3.中断与异常</h2><h3 id="3-1-中断与异常有何区别？"><a href="#3-1-中断与异常有何区别？" class="headerlink" title="3.1 中断与异常有何区别？"></a>3.1 中断与异常有何区别？</h3><p><strong>中断</strong>是指<strong>外部硬件</strong>产生的一个电信号从CPU的中断引脚进入，打断CPU的运行。</p><p><strong>异常</strong>是指软件运行过程中发生了一些<strong>必须作出处理</strong>的事件，CPU自动产生一个陷入来打断CPU的运行。异常在处理的时候必须考虑与处理器的<strong>时钟同步</strong>，实际上异常也称为同步中断，在处理器执行到因编译错误而导致的错误指令时，或者在执行期间出现特殊错误，<strong>必须靠内核处理</strong>的时候，处理器就会产生一个异常。</p><h3 id="3-2-中断与DMA有何区别？"><a href="#3-2-中断与DMA有何区别？" class="headerlink" title="3.2 中断与DMA有何区别？"></a>3.2 中断与DMA有何区别？</h3><p><strong>DMA</strong></p><p>是一种<strong>无须CPU参与</strong>，就可以让<strong>外设与系统内存</strong>之间进行双向数据传输的硬件机制，使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而<strong>大大提高系统的吞吐率</strong>。</p><p><strong>中断</strong></p><p>是指CPU在执行程序的过程中，出现了某些突发事件时，CPU<strong>必须暂停执行当前的程序</strong>，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。</p><p>区别：<strong>DMA不需CPU参与，而中断需要CPU参与</strong>。</p><h3 id="3-3-中断能不能睡眠，为什么？下半部能不能睡眠？"><a href="#3-3-中断能不能睡眠，为什么？下半部能不能睡眠？" class="headerlink" title="3.3 中断能不能睡眠，为什么？下半部能不能睡眠？"></a>3.3 中断能不能睡眠，为什么？下半部能不能睡眠？</h3><ol><li><p>中断处理的时候，不应该发生进程切换。因为在中断上下文中，唯一能打断当前中断handler的<strong>只有更高优先级的中断，它不会被进程打断</strong>。如果在中断上下文中休眠，则没有办法唤醒它，因为所有的wake_up_xxx都是针对某个进程而言的，而在中断上下文中，没有进程的概念，没有一个task_struct（这点对于softirq和tasklet一样）。因此真的休眠了，比如调用了会导致阻塞的例程，<strong>内核几乎肯定会死</strong>。</p></li><li><p>schedule()在切换进程时，保存当前的进程上下文（CPU寄存器的值、进程的状态以及堆栈中的内容），以便以后恢复此进程运行。中断发生后，内核会先保存当前被中断的进程上下文（在调用中断处理程序后恢复）。但<strong>在中断处理程序里，CPU寄存器的值肯定已经变化了</strong>（最重要的程序计数器PC、堆栈SP等）。如果此时因为睡眠或阻塞操作调用了schedule()，则保存的进程上下文就不是当前的进程上下文了。所以，<strong>不可以在中断处理程序中调用schedule()</strong>。</p></li><li><p>2.4内核中schedule()函数本身在<strong>进来的时候判断是否处于中断上下文</strong>。因此，强行调用schedule()的结果就是内核BUG，但看2.6.18的内核schedule()的实现却没有这句，改掉了。</p></li></ol><pre><code>C</code></pre><ol><li><p>中断handler会使用被中断的进程内核堆栈，但不会对它有任何影响，因为handler使用完后会<strong>完全清除它使用的那部分堆栈</strong>，恢复被中断前的原貌。</p></li><li><p>处于中断上下文时候，<strong>内核是不可抢占</strong>的。因此，如果休眠，则内核一定挂起。</p></li></ol><h3 id="3-4-中断的响应执行流程是什么？"><a href="#3-4-中断的响应执行流程是什么？" class="headerlink" title="3.4 中断的响应执行流程是什么？"></a>3.4 中断的响应执行流程是什么？</h3><p>中断的响应流程：<strong>cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半部-&gt;恢复中断上下文</strong>。</p><h3 id="3-5-当一个异常出现以后，ARM微处理器会执行哪几步操作？"><a href="#3-5-当一个异常出现以后，ARM微处理器会执行哪几步操作？" class="headerlink" title="3.5 当一个异常出现以后，ARM微处理器会执行哪几步操作？"></a>3.5 当一个异常出现以后，ARM微处理器会执行哪几步操作？</h3><ol><li><p>将下一条指令的地址存入相应<strong>连接寄存器LR</strong>，以便程序在处理异常返回时能从正确的位置重新开始执行。若异常是从<strong>ARM状态</strong>进入，则LR寄存器中保存的是<strong>下一条指令的地址</strong>（当前PC＋4或PC＋8，与异常的类型有关）；若异常是从<strong>Thumb状态</strong>进入，则在LR寄存器中保存<strong>当前PC的偏移量</strong>，这样，异常处理程序就不需要确定异常是从何种状态进入的。例如：在软件中断异常SWI，指令MOVPC，R14_svc总是返回到下一条指令，不管SWI是在ARM状态执行，还是在Thumb状态执行。</p></li><li><p>将CPSR(程序状态寄存器 current program status register)<strong>复制</strong>到相应的SPSR中。</p></li><li><p>根据异常类型，强制<strong>设置CPSR的运行模式位</strong>。</p></li><li><p>强制PC从相关的异常向量地址取下一条指令执行，从而<strong>跳转到相应的异常处理程序</strong>处。</p></li></ol><h3 id="3-6-写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？"><a href="#3-6-写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？" class="headerlink" title="3.6 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？"></a>3.6 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？</h3><ol><li><p>写一个中断服务程序要注意<strong>快进快出</strong>，在中断服务程序里面尽量<strong>快速采集信息</strong>，包括硬件信息，然后退出中断，要做其它事情可以使用<strong>工作队列</strong>或者<strong>tasklet</strong>方式。也就是中断上半部和下半部。</p></li><li><p>中断服务程序中<strong>不能有阻塞操作</strong>。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作。</p></li><li><p>中断服务程序<strong>注意返回值</strong>，要用操作系统定义的宏做为返回值，而不是自己定义的。</p></li><li><p>如果要做的事情较多，应将这些任务放在<strong>后半段</strong>(tasklet，等待队列等)处理。</p></li></ol><h3 id="3-7-为什么FIQ比IRQ要快？"><a href="#3-7-为什么FIQ比IRQ要快？" class="headerlink" title="3.7 为什么FIQ比IRQ要快？"></a>3.7 为什么FIQ比IRQ要快？</h3><ol><li><p>ARM的FIQ模式提供了<strong>更多的banked寄存器</strong>，r8到r14还有SPSR，而IRQ模式就没有那么多，R8,R9,R10,R11,R12对应的banked的寄存器就没有，这就意味着在ARM的IRQ模式下，中断处理程序<strong>自己要保存R8到R12这几个寄存器</strong>，然后退出中断处理时程序要<strong>恢复这几个寄存器</strong>，而FIQ模式由于这几个寄存器都有banked寄存器，模式切换时CPU<strong>自动保存</strong>这些值到banked寄存器，退出FIQ模式时<strong>自动恢复</strong>，所以这个过程FIQ比IRQ快.不要小看这几个寄存器，ARM在编译的时候，如果你FIQ中断处理程序足够用这几个独立的寄存器来运作，它就不<strong>会进行通用寄存器的压栈</strong>，这样也省了一些时间。</p></li><li><p>FIQ比IRQ有<strong>更高优先级</strong>，如果FIQ和IRQ同时产生，那么FIQ先处理。</p></li><li><p>在symbian系统里，当CPU处于FIQ模式处理FIQ中断的过程中，预取指令异常，未定义指令异常，软件中断全被禁止，所有的中断被屏蔽。所以FIQ就会很快执行，<strong>不会被其他异常或者中断打断</strong>，所以它又比IRQ快了。而IRQ不一样，当ARM处理IRQ模式处理IRQ中断时，如果来了一个FIQ中断请求，那正在执行的IRQ中断处理程序会被抢断，ARM切换到FIQ模式去执行这个FIQ，所以FIQ比IRQ快多了。</p></li><li><p>另外FIQ的入口地址是0x1c,IRQ的入口地址是0x18。写过完整汇编系统的都比较明白这点的差别，18只能放一条指令，为了不与1C处的FIQ冲突，这个地方只能跳转，而FIQ不一样，1C以后<strong>没有任何中断向量表</strong>了，这样可以直接在1C处放FIQ的中断处理程序，由于跳转的范围限制，至少<strong>少了一条跳转指令</strong>。</p></li></ol><h3 id="3-8-中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"><a href="#3-8-中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？" class="headerlink" title="3.8 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"></a>3.8 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h3><ol><li><p>中断是CPU处于<strong>被动</strong>状态下来接受设备的信号，而轮询是CPU<strong>主动</strong>去查询该设备是否有请求。</p></li><li><p>凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个<strong>频繁请求cpu</strong>的设备，或者有<strong>大量数据</strong>请求的网络设备，那么<strong>轮询的效率是比中断高</strong>。如果是一般设备，并且该设备请求cpu的频率比较低，则用<strong>中断效率要高一些</strong>。主要是看<strong>请求频率</strong>。</p></li></ol><h2 id="4-通信协议"><a href="#4-通信协议" class="headerlink" title="4.通信协议"></a>4.通信协议</h2><h3 id="4-1-什么是异步传输和同步传输？"><a href="#4-1-什么是异步传输和同步传输？" class="headerlink" title="4.1 什么是异步传输和同步传输？"></a>4.1 什么是异步传输和同步传输？</h3><p><strong>异步传输</strong>：是一种典型的基于字节的输入输出，数据按每次<strong>一个字节</strong>进行传输，其传输<strong>速度低</strong>。</p><p><strong>同步传输</strong>：需要外界的<strong>时钟信号</strong>进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传输速度比异步传输<strong>快</strong>。</p><h3 id="4-2-RS232和RS485通讯接口有什么区别？"><a href="#4-2-RS232和RS485通讯接口有什么区别？" class="headerlink" title="4.2 RS232和RS485通讯接口有什么区别？"></a>4.2 RS232和RS485通讯接口有什么区别？</h3><ol><li><p><strong>传输方式不同</strong>。RS232采取不平衡传输方式，即所谓<strong>单端通讯</strong>。而RS485则采用平衡传输，即<strong>差分传输</strong>方式。</p></li><li><p><strong>传输距离不同</strong>。RS232适合本地设备之间的通信，传输距离一般<strong>不超过20m</strong>。而RS485的传输距离为<strong>几十米到上千米</strong>。</p></li><li><p><strong>设备数量</strong>。RS232只允许<strong>一对一</strong>通信，而RS485接口在总线上是允许连接<strong>多达128个收发器</strong>。</p></li><li><p><strong>连接方式</strong>。RS232，规定用<strong>电平</strong>表示数据，因此线路就是单线路的，用<strong>两根线才能达到全双工</strong>的目的；而RS485，使用<strong>差分电平</strong>表示数据，因此，必须用<strong>两根线</strong>才能达到传输数据的基本要求，要实现<strong>全双工</strong>，必需用<strong>4根线</strong>。</p></li></ol><p><strong>总结</strong>：从某种意义上，可以说，线路上存在的仅仅是电流，<strong>RS232/RS485规定了这些电流在什么样的线路上流动和流动的样式</strong>。</p><h3 id="4-3-SPI协议"><a href="#4-3-SPI协议" class="headerlink" title="4.3 SPI协议"></a>4.3 SPI协议</h3><p>SPI的应用</p><p>SPI(Serial Peripheral Interface)协议是由摩托罗拉公司提出的通讯协议，即<strong>串行外围设备接口</strong>，是一种<strong>高速全双工</strong>的通信总线。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。SPI总线可直接与各个厂家生产的多种标准外围器件相连，包括FLASH、RAM、网络控制器、LCD显示驱动器、A/D转换器和MCU等。</p><h3 id="4-4-接口"><a href="#4-4-接口" class="headerlink" title="4.4 接口"></a>4.4 接口</h3><ol><li><p><strong>MOSI(MasterOutput，SlaveInput)</strong></p><p> 主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。</p></li><li><p><strong>MISO(MasterInput,，SlaveOutput)</strong></p><p> 主设备输入/从设备输出引脚。主机从这条信号线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。</p></li><li><p><strong>SCLK(SerialClock)</strong></p><p> 时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如STM32的SPI时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。</p></li><li><p><strong>SS(SlaveSelect)</strong></p><p> 从设备选择信号线，常称为片选信号线，也称为NSS、CS，以下用NSS表示。当有多个SPI从设备与SPI主机相连时，设备的其它信号线SCK、MOSI及MISO同时并联到相同的SPI总线上，即无论有多少个从设备，都共同只使用这3条总线；而每个从设备都有独立的这一条NSS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。I2C协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而SPI协议中没有设备地址，它使用NSS信号线来寻址，当主机要选择从设备时，把该从设备的NSS信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行SPI通讯。所以SPI通讯以NSS线置低电平为开始信号，以NSS线被拉高作为结束信号。</p></li></ol><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_.png"></p><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_21f31a802aea8fa8.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_21f31a802aea8fa8.png"></p><ol><li><p><strong>通讯的起始和停止信号</strong></p><p> 在图中的标号1处，NSS信号线<strong>由高变低，是SPI通讯的起始信号</strong>。NSS是每个从机各自独占的信号线，当从机检在自己的NSS线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，<strong>NSS信号由低变高，是SPI通讯的停止信号</strong>，表示本次通讯结束，从机的选中状态被取消。</p></li><li><p><strong>数据有效性</strong></p><p> SPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时，MSB先行（高位先行）或LSB（低位先行）先行并没有作硬性规定，但要保证两个SPI通讯设备之间使用同样的协定，一般都会采用上图中的MSB先行（高位先行）模式。观察图中的2345标号处，<strong>MOSI及MISO的数据在SCK的上升沿期间变化输出，在SCK的下降沿时被采样</strong>。即在<strong>SCK的下降沿时刻，MOSI及MISO的数据有效</strong>，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI及MISO为下一次表示数据做准备。SPI每次数据传输可以8位或16位为单位，每次传输的单位数不受限制。</p></li><li><p><strong>CPOL（时钟极性）/CPHA（时钟相位）及通讯模式</strong></p><p> 上面讲述的图中的时序只是SPI中的其中一种通讯模式，SPI一共有四种通讯模式，它们的主要区别是：总线空闲时SCK的时钟状态以及数据采样时刻。为方便说明，在此引入“时钟极性CPOL”和“时钟相位CPHA”的概念。</p><blockquote><p>时钟极性CPOL是指SPI通讯设备处于空闲状态时，SCK信号线的电平信号(即SPI通讯开始前、NSS线为高电平时SCK的状态)。CPOL=0时，SCK在空闲状态时为低电平，CPOL=1时，则相反。</p></blockquote></li></ol><p>时钟相位CPHA是指数据的采样的时刻，当CPHA=0时，MOSI或MISO数据线上的信号将会在SCK时钟线的“奇数边沿”被采样。当CPHA=1时，数据线在SCK的“偶数边沿”采样。</p><h3 id="4-4-IIC协议"><a href="#4-4-IIC协议" class="headerlink" title="4.4 IIC协议"></a>4.4 IIC协议</h3><p><strong>简介</strong></p><ol><li><p>IIC协议是由<strong>数据线SDA和时钟SCL</strong>构成的串行总线，可发送和接收数据,是一个多主机的<strong>半双工</strong>通信方式</p></li><li><p>每个挂接在总线上的器件都有个<strong>唯一的地址</strong>。位速在标准模式下可达 100kbit/s，在快速模式下可达400kbit/s，在高速模式下可待3.4Mbit/s。</p></li><li><p>I2C总线系统结构,如下所示:</p><p> <img src="https://tuchuang.voooe.cn/images/2023/03/18/_0e8765696e41629a.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_0e8765696e41629a.png"></p></li></ol><p><strong>时序介绍</strong></p><ol><li><p>空闲状态<br>当总线上的SDA和SCL<strong>两条信号线同时处于高电平，便是空闲状态</strong>，如上面的硬件图所示，当我们不传输数据时，SDA和SCL被上拉电阻拉高，即进入空闲状态</p></li><li><p>起始信号<br>当<strong>时钟线SCL为高期间，数据线SDA由高到低(下降沿)的跳变；便是总线的启动</strong>信号，只能由<strong>主机</strong>发起，且在空闲状态下才能启动该信号，如下图所示：</p></li></ol><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_02de16c30bdfa26e.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_02de16c30bdfa26e.png"></p><p><strong>停止信号</strong></p><ul><li>当<strong>SCL为高期间，SDA由低到高(上升沿)的跳变；便是总线的停止</strong>信号,表示数据已传输完成，如下图所示：</li></ul><blockquote><p>总结：时钟线SCL与数据线SDA、半双工、空闲时两线高电平、起始与停止SCL均为高电平(SDa下降沿开始、上升沿结束)</p></blockquote><p><strong>传输数据格式</strong><br>当发了起始信号后,就开始传输数据,传输的数据格式如下图所示：</p><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_d78c7db3a8a0f5d7.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_d78c7db3a8a0f5d7.png"></p><ol><li><p>当<strong>SCL为高电平时，便会获取SDA数据</strong>，其中SDA数据必须是<strong>稳定</strong>的(若SDA不稳定就会变成起始/停止信<br>号)。</p></li><li><p>当SCL为<strong>低电平</strong>时，便是SDA的电平<strong>变化</strong>状态。</p></li><li><p>若主从机在传输数据期间，需要完成其它功能(例如一个<strong>中断</strong>)，可以<strong>主动拉低SCL</strong>，使I2C进入<strong>等待</strong>(不读取)状态，直到处理结束再释放SCL，数据传输会继续。</p></li></ol><p><strong>应答信号ACK</strong></p><ul><li><p>I2C总线上的数据都是以<strong>8位数据(一个字节</strong>)进行的，当发送了8个数据后，发送方会在<strong>第9个时钟脉冲期间</strong>释放SDA数据，当接收方接收该字节成功，便会输出一个ACK应答信号，当SDA为高电平，表示为非应答信号NACK，当<strong>SDA为低电平，表示为有效应答信号ACK</strong>(记住是接收方发送ACK信号)</p></li><li><p>PS:当主机为接收方时，收到<strong>最后</strong>一个字节后，主机可以不发送ACK，直接发送<strong>停止信号</strong>来结束传输。</p></li><li><p>当从机为接收方时，没有发送ACK，则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机发送，主机可以发送停止信号，再次发送起始信号<strong>启动新的传输</strong>。</p></li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_632beb8c0c138d38.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_632beb8c0c138d38.png"></p><p><strong>完整的数据传输</strong></p><ul><li><p>如下图所示，发送起始信号后，便发送一个<strong>8位的设备地址</strong>，其中<strong>第8位是对设备的读写标志</strong>，后面紧跟着的就是数据了，直到发送停止信号终止。</p></li><li><p>PS:当我们第一次是读操作，然后想换成写操作时，可以<strong>再次发送一个起始信号</strong>，然后发送读的设备地址，不需要停止信号便能实现<strong>不同的地址转换</strong>。</p></li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_0c443cec30276300.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_0c443cec30276300.png"></p><p><strong>IIC传输数据的格式</strong></p><ul><li><p><strong>写操作</strong></p><p>  刚开始主芯片要发出一个<strong>start信号</strong>，然后发出一个(用来确定是往哪一个芯片写数据，即器件地址)，<strong>方向</strong>(读/写，0表示写，1表示读)。回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个<strong>回应</strong>信号（确定数据是否接受完成)，然后再传输下一个数据。<strong>每传输一个数据，接受方都会有一个回应信号</strong>，数据发送完之后，主芯片就会发送一个停止信号。<br>白色：主→从 | 灰色：从→主。</p></li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_7b444066e8987422.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_7b444066e8987422.png"></p><ul><li><strong>读操作</strong><br>刚开始主芯片要发出一个<strong>start信号</strong>，然后发出一个<strong>设备地址</strong>(用来确定是从哪一个芯片读取数据)，方向(读/写，0表示写，1表示读)。回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后在传输下一个数据。<strong>每传输一个数据，接受方都会有一个回应信号</strong>，数据发送完之后，主芯片就会发送一个停止信号。<br>白色：主→从 | 灰色：从→主</li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_fad840b315ab024c.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_fad840b315ab024c.png"></p><blockquote><p>注意灰色与白色的不同，其实搞清楚读那个就是只要发送开始信号和回应即可</p></blockquote><h2 id="5-编程"><a href="#5-编程" class="headerlink" title="5.编程"></a>5.编程</h2><p><strong>嵌人式编程中，什么是大端？什么是小端？</strong><br>大端模式：低位字节存在高地址上，高位字节存在低地址上。<br>小端模式：高位字节存在高地址上，低位字节存在低地址上。</p><p><img src="https://tuchuang.voooe.cn/images/2023/03/19/_.png" alt="https://tuchuang.voooe.cn/images/2023/03/19/_.png"></p><p>STM32属于小端模式，简单的说，比如<code>u32 temp=0X12345678</code>；假设temp地址在0X2000 0010。那么内存里面,存放就变成了：</p><p>PLAINTEXT</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>因为是16进制的，一个数为0.5字节，所以 12 代表一个字节 34 代表一个字节。<br>釆用小端模式的CPU对操作数的存放方式是从低字节到高字节，而大端模式对操作数的存放方式是从高字节到低字节。例如，16位宽的数<code>0x1234</code>在小端模式CPU内存中的存放方式（假设从地址<code>0x4000</code>开始存放）见表1，而在大端模式CPU内存中的存放方式见表2。</p><p>表1：0x1234在小端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x34</td></tr><tr><td>0x4001</td><td>0x12</td></tr></tbody></table></div><p>表2：0x1234在大端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x12</td></tr><tr><td>0x4001</td><td>0x34</td></tr></tbody></table></div><p>32位宽的数<code>0x12345678</code>在小端模式CPU内存中的存放方式（假设从地址0x4000开始存放）见表3，而在大端模式CPU内存中的存放方式见表4。</p><p>表3：0x12345678在小端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x78</td></tr><tr><td>0x4001</td><td>0x56</td></tr><tr><td>0x4002</td><td>0x34</td></tr><tr><td>0x4003</td><td>0x12</td></tr></tbody></table></div><p>表4：0x12345678在大端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x12</td></tr><tr><td>0x4001</td><td>0x34</td></tr><tr><td>0x4002</td><td>0x56</td></tr><tr><td>0x4003</td><td>0x78</td></tr></tbody></table></div><p>以下程序为例：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>程序的输出结果为 50。<br>上例中，<code>sizeof(test)=2</code>，上例的声明方式是把一个 short（也就是一块16位内存）分成3部分，各部分的大小分别是4位、5位、7位，赋值语句<code>i*(short*)&amp;test）</code>就是把上面的16位内存转换成 short类型进行解释。<br>变量a的二进制表示为0000000000000010，取其低四位是<code>0010</code>.变量b的二进制表示为0000000000000011，取其低五位是<code>00011</code>。变量c的二进制表示为0000000000000000，取其低七位是<code>0000000</code>。<br><strong>80x86机是小端（修改分区表时要注意）模式，单片机一般为大端模式</strong>。小端一般是低位字节在高位字节的前面，也就是低位在内存地址低的一端，可以这样记（小端→低位→在前→与正常逻辑顺序相反），所以合成后得到<code>0000000000110010</code>，即十进制的50。<br>下面给出另外一个例子</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>小端模式是低地址存放低字节，高地址存放高字节，结构如下所示：</p><p>78 //低地址<br>56<br>34<br>12 //高地址</p><p>在内存里面测试机是小端，地址由小到大。</p><p>val1:78563412<br>val2:12345678</p><p>结果如下：</p><p>7856<br>3412</p><p><strong>如何判断计算机处理器是大端，还是小端？</strong></p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>编者的处理器为Intel处理器，因为Intel处理器一般都是小端模式，所以此时程序的输出结果为：小端<br>上述代码中，如果处理器是大端，则返回0；如果处理器是小端，则返回1。联合体 union的存放顺序是所有成员都从低地址开始存放，如果能够通过改代码知道CPU对内存是采用小端模式读写，还是采用大端模式读写，一定会令面试官刮目相看。<br>还可以通过指针地址来判断，由于在32位计算机系统中， short占两个字节，char占1个字节，所以可以采用如下做法实现该判断。</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>char类型转换会截取低位地址的值，因此如果低位存放的是22，那么说明低位地址存放低位数据，因此说明就是小端存储，即程序输出的结果为：小端</p><p><strong>如何进行大小端的转换？</strong></p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>如何对绝对地址0x100000赋值？</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p><p>首先要将0x100000强制转换成函数指针,即：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>然后再调用它：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>用typedef可以看得更直观些：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git全面教程——简介！！！</title>
      <link href="/2023/08/27/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/08/27/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>Git是什么？</p><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><p>Git有什么特点？简单来说就是：高端大气上档次！</p><p>那什么是版本控制系统？</p><p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：</p><p>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p><p><img src="https://cdn.flowus.cn/oss/378fa915-9cca-448c-9ec4-181f1d379070/0.jpg?time=1693310400&amp;token=09bf82f4b70e3af2e19f5e9348cd9990&amp;role=share&amp;img_process=/resize,w_392/quality,q_90/" alt="0.jpg"></p><p>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。</p><p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p><p>更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。</p><p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p><p>这个软件用起来就应该像这个样子，能记录每次文件的改动：</p><div class="table-container"><table><thead><tr><th>版本</th><th>文件名</th><th>用户</th><th>说明</th><th>日期</th></tr></thead><tbody><tr><td>1</td><td>service.doc</td><td>张三</td><td>删除了软件服务条款5</td><td>7/12 10:38</td></tr><tr><td>2</td><td>service.doc</td><td>张三</td><td>增加了License人数限制</td><td>7/12 18:09</td></tr><tr><td>3</td><td>service.doc</td><td>李四</td><td>财务部门调整了合同金额</td><td>7/13 9:51</td></tr><tr><td>4</td><td>service.doc</td><td>张三</td><td>延长了免费升级周期</td><td>7/14 15:17</td></tr></tbody></table></div><p>这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。</p><h1 id="git的诞生"><a href="#git的诞生" class="headerlink" title="git的诞生"></a>git的诞生</h1><p>  很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><h1 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h1><p>Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p><p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/918921540355872/l" alt="https://www.liaoxuefeng.com/files/attachments/918921540355872/l"></p><p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p><p>那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/918921562236160/l" alt="https://www.liaoxuefeng.com/files/attachments/918921562236160/l"></p><p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p><p>CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p><p>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p><p>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p><p>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p><p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p><h2 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h2><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &#x27;git&#x27; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p><p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p><h2 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h2><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/">http://brew.sh/</a>。</p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919018691743136/0" alt="https://www.liaoxuefeng.com/files/attachments/919018691743136/0"></p><p>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p><h2 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h2><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919018718363424/0" alt="https://www.liaoxuefeng.com/files/attachments/919018718363424/0"></p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p><p>第二步，通过<code>git init</code>命令把这个目录变成GitGit可以管理的仓库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p><strong>使用Windows的童鞋要特别注意：</strong></p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="https://code.visualstudio.com/">Visual Studio Code</a>代替记事本，不但功能强大，而且免费！</p><p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p><strong>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><h3 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a><strong>疑难解答</strong></h3><p><strong>Q：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。</strong></p><p><strong>A：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</strong></p><p><strong>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec &#39;readme.txt&#39; did not match any files</code>。</strong></p><p><strong>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>现在总结一下今天学的两点内容：</strong></p><p><strong>初始化一个Git仓库，使用<code>git init</code>命令。</strong></p><p><strong>添加文件到Git仓库，分两步：</strong></p><ol><li><p><strong>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</strong></p></li><li><p><strong>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习技能 </category>
          
          <category> git全面教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git全面教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first</title>
      <link href="/2023/08/26/%E5%89%8D%E7%AB%AF-qianduan/"/>
      <url>/2023/08/26/%E5%89%8D%E7%AB%AF-qianduan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first</title>
      <link href="/2023/08/26/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-jineng/"/>
      <url>/2023/08/26/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-jineng/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>posts</title>
      <link href="/2023/08/25/%E5%90%8E%E7%AB%AF-houduan/"/>
      <url>/2023/08/25/%E5%90%8E%E7%AB%AF-houduan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git教程</title>
      <link href="/2023/08/25/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%97%B6%E5%85%89%E6%9C%BA%E7%A9%BF%E6%A2%AD/"/>
      <url>/2023/08/25/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%97%B6%E5%85%89%E6%9C%BA%E7%A9%BF%E6%A2%AD/</url>
      
        <content type="html"><![CDATA[<p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>现在，运行<code>git status</code>命令看看结果：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add distributed&quot;</span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p></li><li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><!-- GitCalendar容器 --></h1><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {                    }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){var t=new Date("08/24/2023 00:00:00");now.setTime(now.getTime()+250);var e=(now-t)/1e3/60/60/24,a=Math.floor(e),n=(now-t)/1e3/60/60-24*a,r=Math.floor(n);1==String(r).length&&(r="0"+r);var s=(now-t)/1e3/60-1440*a-60*r,i=Math.floor(s);1==String(i).length&&(i="0"+i);var o=(now-t)/1e3-86400*a-3600*r-60*i,l=Math.round(o);1==String(l).length&&(l="0"+l);let g="";g=r<18&&r>=9?`<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-上班摸鱼中.svg' title='距离月入25k也就还差一个大佬带我~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`:`<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-下班啦.svg' title='下班了就该开开心心的玩耍，嘿嘿~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=g)}setInterval((()=>{createtime()}),250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  @font-face {    /* 为载入的字体取名字(随意) */    font-family: 'YSHST';    /* 字体文件地址(相对或者绝对路径都可以) */    src: url(/font/优设好身体.woff2);    /* 定义加粗样式(加粗多少) */    font-weight: normal;    /* 定义字体样式(斜体/非斜体) */    font-style: normal;    /* 定义显示样式 */    font-display: block;  }/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {  left: -125px;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px var(rgb(179, 71, 241)) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px var(rgb(179, 71, 241)) !important;}/* 闪烁变动颜色连续渐变 */#site-name,#site-title,#site-subtitle,#post-info,.author-info__name,.author-info__description {  transition: text-shadow 1s linear !important;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: rgb(57, 134, 197);  border-radius: 8px;  opacity: 0.25;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}#cursor.hidden {  opacity: 0;}#cursor.hover {  opacity: 0.1;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}#cursor.active {  opacity: 0.5;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}:root {  --trans-light: rgba(255, 255, 255, 0.75);  --trans-dark: rgba(25, 25, 25, 0.88);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.min.css"/>
      <url>/css/runtime.min.css</url>
      
        <content type="html"><![CDATA[div#runtime{width:180px;margin:auto;color:#fff;padding-inline:5px;border-radius:10px;background-color:rgba(0,0,0,.7)}#workboard{font-size:12px}[data-theme=dark] div#runtime{color:#28b4c8;box-shadow:0 0 5px rgba(28,69,218,.71);animation:flashlight 1s linear infinite alternate}#ghbdages .github-badge img{height:20px}@-moz-keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}@-webkit-keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}@-o-keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}@keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
