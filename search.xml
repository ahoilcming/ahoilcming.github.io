<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue基础内容</title>
      <link href="/2023/09/06/%E5%89%8D%E7%AB%AF-vue%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
      <url>/2023/09/06/%E5%89%8D%E7%AB%AF-vue%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="vue基础内容"><a href="#vue基础内容" class="headerlink" title="vue基础内容"></a>vue基础内容</h2><h3 id="初识Vue"><a href="#初识Vue" class="headerlink" title="初识Vue"></a>初识Vue</h3><ol><li><p>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p></li><li><p>root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p></li><li><p>root容器里的代码被称为【Vue模板】；</p></li><li><p>Vue实例和容器是一一对应的；</p></li><li><p>真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p></li><li><p><code>&#123;&#123;xxx&#125;&#125;</code>中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p></li><li><p>一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p><p>注意区分：js表达式 和 js代码(语句)</p><ul><li>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：<br>(1). a<br>(2). a+b<br>(3). demo(1)<br>(4). x === y ? ‘a’ : ‘b’</li><li>js代码(语句)<br>(1). if(){}<br>(2). for(){}</li></ul></li></ol><h3 id="Vue模版语法"><a href="#Vue模版语法" class="headerlink" title="Vue模版语法"></a>Vue模版语法</h3><p>Vue模板语法有2大类：</p><ol><li>插值语法：<br>功能：用于解析标签体内容。<br>写法：<code>&#123;&#123;xxx&#125;&#125;</code>，xxx是js表达式，且可以直接读取到data中的所有属性。</li><li>指令语法：<br>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。<br>举例：v-bind:href=”xxx” 或 简写为 :href=”xxx”，xxx同样要写js表达式，<br>且可以直接读取到data中的所有属性。<br>备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</li></ol><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>Vue中有2种数据绑定的方式：</p><ol><li><p>单向绑定(v-bind)：数据只能从data流向页面。</p></li><li><p>双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p><p>备注：</p><ul><li>双向绑定一般都应用在表单类元素上（如：input、select等）</li><li>v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</li></ul></li></ol><h3 id="data与el的2种写法"><a href="#data与el的2种写法" class="headerlink" title="data与el的2种写法"></a>data与el的2种写法</h3><ol><li>el有2种写法<br>(1).new Vue时候配置el属性。<br>(2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</li><li>data有2种写法<br>(1).对象式<br>(2).函数式<br>如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</li><li>一个重要的原则：<br>由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。（最终目的是让this指向vm）</li></ol><h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h3><ol><li>M：模型(Model) ：data中的数据</li><li>V：视图(View) ：模板代码</li><li>VM：视图模型(ViewModel)：Vue实例<br>观察发现：</li><li>data中所有的属性，最后都出现在了vm身上。</li><li>vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。<br>是因为data最后合并到了vm中。</li></ol><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h3><ol><li>Vue中的数据代理：<br>通过vm对象来代理data对象中属性的操作（读/写）</li><li>Vue中数据代理的好处：<br>更加方便的操作data中的数据</li><li>基本原理：<br>通过Object.defineProperty()把data对象中所有属性添加到vm上。<br>为每一个添加到vm上的属性，都指定一个getter/setter。<br>在getter/setter内部去操作（读/写）data中对应的属性。</li></ol><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="事件的基本使用："><a href="#事件的基本使用：" class="headerlink" title="事件的基本使用："></a>事件的基本使用：</h4><ol><li>使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</li><li>事件的回调需要配置在methods对象中，最终会在vm上；</li><li>methods中配置的函数，不要用箭头函数！否则this就不是vm了；</li><li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</li><li>@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参；</li></ol><h4 id="Vue中的事件修饰符："><a href="#Vue中的事件修饰符：" class="headerlink" title="Vue中的事件修饰符："></a>Vue中的事件修饰符：</h4><ol><li>prevent：阻止默认事件（常用）；</li><li>stop：阻止事件冒泡（常用）；</li><li>once：事件只触发一次（常用）；</li><li>capture：使用事件的捕获模式；</li><li>self：只有event.target是当前操作的元素时才触发事件；</li><li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕；（多用于优化，类似异步）</li></ol><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ol><li>Vue中常用的按键别名：<br>回车 =&gt; enter<br>删除 =&gt; delete (捕获“删除”和“退格”键)<br>退出 =&gt; esc<br>空格 =&gt; space<br>换行 =&gt; tab (特殊，必须配合keydown去使用，因为若keyup会先切走，这时候event就丢失了。)<br>上 =&gt; up<br>下 =&gt; down<br>左 =&gt; left<br>右 =&gt; right</li><li>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</li><li>系统修饰键（用法特殊）：ctrl、alt、shift、meta<br>(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。<br>(2).配合keydown使用：正常触发事件。</li><li>也可以使用keyCode去指定具体的按键（不推荐）</li><li>Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</li></ol><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ol><li>定义：要用的属性不存在，要通过已有属性计算得来。</li><li>原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</li><li>get函数什么时候执行？<br>(1).初次读取时会执行一次。<br>(2).当依赖的数据发生改变时会被再次调用。</li><li>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</li><li>备注：<ul><li>计算属性最终会出现在vm上，直接读取使用即可。</li><li>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</li></ul></li></ol><h3 id="监视属性watch："><a href="#监视属性watch：" class="headerlink" title="监视属性watch："></a>监视属性watch：</h3><ol><li>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</li><li>监视的属性必须存在，才能进行监视！！</li><li>监视的两种写法：<br>(1).new Vue时传入watch配置<br>(2).通过vm.$watch监视</li><li>深度监视：<br>(1).Vue中的watch默认不监测对象内部值的改变（一层）。<br>(2).配置deep:true可以监测对象内部值改变（多层）。<br>备注：<br>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！<br>(2).使用watch时根据数据的具体结构，决定是否采用深度监视。为了效率更高，简单结构无需开深度监视。</li><li>computed和watch之间的区别：<ul><li>computed能完成的功能，watch都可以完成。</li><li>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</li></ul></li><li>两个重要的小原则：<ul><li>所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</li><li>所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，<br>这样this的指向才是vm 或 组件实例对象。</li></ul></li></ol><h3 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h3><ol><li>class样式<br>写法:class=”xxx” xxx可以是字符串、对象、数组。<br>字符串写法适用于：类名不确定，要动态获取。<br>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。<br>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li><li>style样式<br>:style=”{fontSize: xxx}”其中xxx是动态值。<br>:style=”[a,b]”其中a、b是样式对象。</li></ol><h3 id="条件渲染："><a href="#条件渲染：" class="headerlink" title="条件渲染："></a>条件渲染：</h3><ol><li>v-if<br>写法：<br>(1).v-if=”表达式”<br>(2).v-else-if=”表达式”<br>(3).v-else=”表达式”<br>适用于：切换频率较低的场景。<br>特点：不展示的DOM元素直接被移除。<br>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</li><li>v-show<br>写法：v-show=”表达式”<br>适用于：切换频率较高的场景。<br>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</li><li>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</li></ol><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令:"></a>v-for指令:</h4><ol><li>用于展示列表数据</li><li>语法：v-for=”(item, index) in xxx” :key=”yyy”</li><li>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</li></ol><h4 id="面试题：react、vue中的key有什么作用？（key的内部原理）"><a href="#面试题：react、vue中的key有什么作用？（key的内部原理）" class="headerlink" title="面试题：react、vue中的key有什么作用？（key的内部原理）"></a>面试题：react、vue中的key有什么作用？（key的内部原理）</h4><ol><li><p>虚拟DOM中key的作用：<br>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p></li><li><p>对比规则：<br>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p><p>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>创建新的真实DOM，随后渲染到到页面。</p></li><li><p>用index作为key可能会引发的问题：</p><ul><li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</li><li>如果结构中还包含输入类的DOM：<br>会产生错误DOM更新 ==&gt; 界面有问题。</li></ul></li><li><p>开发中如何选择key?:</p><ul><li>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>使用index作为key是没有问题的。</li></ul></li></ol><h4 id="Vue监视数据的原理："><a href="#Vue监视数据的原理：" class="headerlink" title="Vue监视数据的原理："></a>Vue监视数据的原理：</h4><ol><li>vue会监视data中所有层次的数据。</li><li>如何监测对象中的数据？<br>通过setter实现监视，且要在new Vue时就传入要监测的数据。<br>(1).对象中后追加的属性，Vue默认不做响应式处理<br>(2).如需给后添加的属性做响应式，请使用如下API：<br>Vue.set(target，propertyName/index，value) 或<br>vm.$set(target，propertyName/index，value)</li><li>如何监测数组中的数据？<br>通过包裹数组更新元素的方法实现，本质就是做了两件事：<br>(1).调用原生对应的方法对数组进行更新。<br>(2).重新解析模板，进而更新页面。</li><li>在Vue修改数组中的某个元素一定要用如下方法：<br>1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>2.Vue.set() 或 vm.$set()</li></ol><p>特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p><h3 id="收集表单数据："><a href="#收集表单数据：" class="headerlink" title="收集表单数据："></a>收集表单数据：</h3><p>若：<code>&lt;input type=&quot;text&quot;/&gt;</code>，则v-model收集的是value值，用户输入的就是value值。<br>若：<code>&lt;input type=&quot;radio&quot;/&gt;</code>，则v-model收集的是value值，且要给标签配置value值。<br>若：<code>&lt;input type=&quot;checkbox&quot;/&gt;</code><br>1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>2.配置input的value属性:<br>(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>(2)v-model的初始值是数组，那么收集的的就是value组成的数组<br>备注：v-model的三个修饰符：<br>lazy：失去焦点再收集数据<br>number：输入字符串转为有效的数字<br>trim：输入首尾空格过滤</p><h3 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h3><p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。<br>语法：<br>1.注册过滤器：<code>Vue.filter(name,callback)</code> 或 <code>new Vue&#123;filters:&#123;&#125;&#125;</code><br>2.使用过滤器：<code>&#123;&#123; xxx | 过滤器名&#125;&#125;</code> 或 <code>v-bind:属性 = &quot;xxx | 过滤器名&quot;</code><br>备注：<br>1.过滤器也可以接收额外参数、多个过滤器也可以串联<br>2.并没有改变原本的数据, 是产生新的对应的数据</p><h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h3><ol><li>v-bind : 单向绑定解析表达式, 可简写为 :xxx</li><li>v-model : 双向数据绑定</li><li>v-for : 遍历数组/对象/字符串</li><li>v-on : 绑定事件监听, 可简写为@</li><li>v-if : 条件渲染（动态控制节点是否存存在）</li><li>v-else : 条件渲染（动态控制节点是否存存在）</li><li>v-show : 条件渲染 (动态控制节点是否展示)</li><li>v-text指令：<ul><li>作用：向其所在的节点中渲染文本内容。</li><li>与插值语法的区别：v-text会替换掉节点中的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。</li></ul></li><li>v-html指令：<ul><li>作用：向指定节点中渲染包含html结构的内容。</li><li>与插值语法的区别：<br>(1).v-html会替换掉节点中所有的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。<br>(2).v-html可以识别html结构。</li><li>严重注意：v-html有安全性问题！！！！<br>(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。<br>(2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</li></ul></li><li>v-cloak指令（没有值）：<ul><li>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</li><li>使用css配合v-cloak可以解决网速慢时页面展示出<code>&#123;&#123;xxx&#125;&#125;</code>的问题。</li></ul></li><li>v-once指令：<ul><li>v-once所在节点在初次动态渲染后，就视为静态内容了。</li><li>以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li></ul></li><li>v-pre指令：<ul><li>跳过其所在节点的编译过程。</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li></ul></li></ol><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。<br>需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。<br>自定义指令总结：<br>一、定义语法：<br>(1).局部指令：<br>new Vue({ new Vue({<br>directives:{指令名:配置对象} 或 directives{指令名:回调函数}<br>}) })<br>(2).全局指令：<br>Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)</p><p>二、配置对象中常用的3个回调：<br>(1).bind：指令与元素成功绑定时调用。<br>(2).inserted：指令所在元素被插入页面时调用。<br>(3).update：指令所在模板结构被重新解析时调用。</p><p>三、备注：<br>(1).指令定义时不加v-，但使用时要加v-；<br>(2).指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><ol><li><p>又名：生命周期回调函数、生命周期函数、生命周期钩子。</p></li><li><p>是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p></li><li><p>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p></li><li><p>生命周期函数中的this指向是vm 或 组件实例对象。</p><p>常用的生命周期钩子：</p><ol><li>mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</li><li>beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</li></ol></li></ol><p>关于销毁Vue实例</p><ol><li>销毁后借助Vue开发者工具看不到任何信息。</li><li>销毁后自定义事件会失效，但原生DOM事件依然有效。</li><li>一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</li></ol><h3 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h3><h4 id="Vue中使用组件的三大步骤："><a href="#Vue中使用组件的三大步骤：" class="headerlink" title="Vue中使用组件的三大步骤："></a>Vue中使用组件的三大步骤：</h4><p>一、定义组件(创建组件)<br>二、注册组件<br>三、使用组件(写组件标签)</p><p>一、如何定义一个组件？<br>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；<br>区别如下：<br>1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。<br>2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。<br>备注：使用template可以配置组件结构。</p><p>二、如何注册组件？<br>1.局部注册：靠new Vue的时候传入components选项<br>2.全局注册：靠Vue.component(‘组件名’,组件)</p><p>三、编写组件标签：<br><code>&lt;school&gt;&lt;/school&gt;</code></p><h4 id="几个注意点："><a href="#几个注意点：" class="headerlink" title="几个注意点："></a>几个注意点：</h4><ol><li>关于组件名:<br>一个单词组成：<br>第一种写法(首字母小写)：school<br>第二种写法(首字母大写)：School<br>多个单词组成：<br>第一种写法(kebab-case命名)：my-school(配置项里要用引号包起来)<br>第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)<br>备注：<br>(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。<br>(2).可以使用name配置项指定组件在开发者工具中呈现的名字。</li><li>关于组件标签:<br>第一种写法：<br>第二种写法：<br>备注：不用使用脚手架时，会导致后续组件不能渲染。</li><li>一个简写方式：<br>const school = Vue.extend(options) 可简写为：const school = options</li></ol><h4 id="关于VueComponent："><a href="#关于VueComponent：" class="headerlink" title="关于VueComponent："></a>关于VueComponent：</h4><ol><li>school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</li><li>我们只需要写<code>&lt;school/&gt;</code>或<code>&lt;school&gt;&lt;/school&gt;</code>，Vue解析时会帮我们创建school组件的实例对象，<br>即Vue帮我们执行的：<code>new VueComponent(options)</code>。调用是解析时进行的，和简写时有没有Vue.extend无关。</li><li>特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！</li><li>关于this指向：<br>(1).组件配置中：<br>data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。<br>(2).new Vue(options)配置中：<br>data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</li><li>VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。<br>Vue的实例对象，以后简称vm。<br>差别就在于el这种根实例特有的选项。</li></ol><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><ol><li>一个重要的内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code></li><li>为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</li></ol><h2 id="Vue脚手架（vue2）"><a href="#Vue脚手架（vue2）" class="headerlink" title="Vue脚手架（vue2）"></a>Vue脚手架（vue2）</h2><h3 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules </span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico: 页签图标</span><br><span class="line">│   └── index.html: 主页面</span><br><span class="line">├── src</span><br><span class="line">│   ├── assets: 存放静态资源</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   │── component: 存放组件</span><br><span class="line">│   │   └── HelloWorld.vue</span><br><span class="line">│   │── App.vue: 汇总所有组件</span><br><span class="line">│   │── main.js: 入口文件</span><br><span class="line">├── .gitignore: git版本管制忽略的配置</span><br><span class="line">├── babel.config.js: babel的配置文件</span><br><span class="line">├── package.json: 应用包配置文件 </span><br><span class="line">├── README.md: 应用描述文件</span><br><span class="line">├── package-lock.json：包版本控制文件</span><br></pre></td></tr></table></figure><h3 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h3><ol><li>vue.js与vue.runtime.xxx.js的区别：<ul><li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li></ul></li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li></ol><h3 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h3><ol><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><h3 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h3><ol><li>被用来给元素或子组件注册引用信息（id的替代者）</li><li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ul><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ul></li></ol><h3 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h3><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;]</code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">name:&#123;</span><br><span class="line">type:String, //类型</span><br><span class="line">required:true, //必要性</span><br><span class="line">default:&#x27;老王&#x27; //默认值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote></li></ol></li></ol><h3 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h3><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p>第一步定义混合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NIM</span><br><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步使用混入：</p><p> 全局混入：<code>Vue.mixin(xxx)</code><br>​ 局部混入：<code>mixins:[&#39;xxx&#39;]</code></p></li></ol><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">对象.install = function (Vue, options) &#123;</span><br><span class="line">    // 1. 添加全局过滤器</span><br><span class="line">    Vue.filter(....)</span><br><span class="line"></span><br><span class="line">    // 2. 添加全局指令</span><br><span class="line">    Vue.directive(....)</span><br><span class="line"></span><br><span class="line">    // 3. 配置全局混入(合)</span><br><span class="line">    Vue.mixin(....)</span><br><span class="line"></span><br><span class="line">    // 4. 添加实例方法</span><br><span class="line">    Vue.prototype.$myMethod = function () &#123;...&#125;</span><br><span class="line">    Vue.prototype.$myProperty = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h3 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h3><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h3 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h3><ol><li><p>组件化编码流程：</p><p> (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p> (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p> 1).一个组件在用：放在组件自身即可。</p><p> 2). 一些组件在用：放在他们共同的父组件上（状态提升）。</p><p> (3).实现交互：从绑定事件开始。</p></li><li><p>props适用于：</p><p> (1).父组件 ==&gt; 子组件 通信</p><p> (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p></li><li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p></li><li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p></li></ol><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h3><ol><li>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</li><li>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</li><li>相关API：<ol><li><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li><li><code>xxxxxStorage.getItem(&#39;person&#39;);</code><br>​该方法接受一个键名作为参数，返回键名对应的值。</li><li><code>xxxxxStorage.removeItem(&#39;key&#39;);</code><br>​该方法接受一个键名作为参数，并把该键名从存储中删除。</li><li><code>xxxxxStorage.clear()</code><br>​该方法会清空存储中的所有数据。</li></ol></li><li>备注：<ol><li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li><li><code>JSON.parse(null)</code>的结果依然是null。</li></ol></li></ol><h3 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h3><ol><li><p>一种组件间通信的方式，适用于：<strong>子组件 ===&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code> 或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">&lt;Demo ref=&quot;demo&quot;/&gt;</span><br><span class="line">......</span><br><span class="line">mounted()&#123;</span><br><span class="line">   this.$refs.xxx.$on(&#x27;atguigu&#x27;,this.test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！</p></li></ol><h3 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h3><ol><li><p>一种组件间通信的方式，适用于任意组件间通信。</p></li><li><p>安装全局事件总线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">......</span><br><span class="line">beforeCreate() &#123;</span><br><span class="line">Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm</span><br><span class="line">&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">methods()&#123;</span><br><span class="line">  demo(data)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.$bus.$on(&#x27;xxxx&#x27;,this.demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。</p></li></ol><h3 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h3><ol><li><p>一种组件间通信的方式，适用于任意组件间通信。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">methods()&#123;</span><br><span class="line">  demo(data)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo) //订阅消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去取消订阅。</p></li></ol></li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h3 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h3><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" alt="img"></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><h3 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p> 在vue.config.js中添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">devServer:&#123;</span><br><span class="line">  proxy:&quot;http://localhost:5000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p> 编写vue.config.js配置具体代理规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">devServer: &#123;</span><br><span class="line">      proxy: &#123;</span><br><span class="line">      &#x27;/api1&#x27;: &#123;// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span><br><span class="line">        target: &#x27;http://localhost:5000&#x27;,// 代理目标的基础路径</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x27;/api2&#x27;: &#123;// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span><br><span class="line">        target: &#x27;http://localhost:5001&#x27;,// 代理目标的基础路径</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span><br><span class="line">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span><br><span class="line">   changeOrigin默认值为true</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong>父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p> 在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h4 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h4><p> 多个组件需要共享数据时</p><h4 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h4><ol><li><p>创建文件：<code>src/store/index.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">//引入Vue核心库</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入Vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">//应用Vuex插件</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">//准备actions对象——响应组件中用户的动作</span><br><span class="line">const actions = &#123;&#125;</span><br><span class="line">//准备mutations对象——修改state中的数据</span><br><span class="line">const mutations = &#123;&#125;</span><br><span class="line">//准备state对象——保存具体的数据</span><br><span class="line">const state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">//创建并暴露store</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">//引入store</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//创建vm</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#app&#x27;,</span><br><span class="line">render: h =&gt; h(App),</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h4><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">//引入Vue核心库</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入Vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">//引用Vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">    //响应组件中加的动作</span><br><span class="line">jia(context,value)&#123;</span><br><span class="line">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span><br><span class="line">context.commit(&#x27;JIA&#x27;,value)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations = &#123;</span><br><span class="line">    //执行加</span><br><span class="line">JIA(state,value)&#123;</span><br><span class="line">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span><br><span class="line">state.sum += value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化数据</span><br><span class="line">const state = &#123;</span><br><span class="line">   sum:0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建并暴露store</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h4 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h4><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">const getters = &#123;</span><br><span class="line">bigSum(state)&#123;</span><br><span class="line">return state.sum * 10</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建并暴露store</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">......</span><br><span class="line">getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h4 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h4><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    //借助mapState生成计算属性：sum、school、subject（对象写法）</span><br><span class="line">     ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;),</span><br><span class="line">         </span><br><span class="line">    //借助mapState生成计算属性：sum、school、subject（数组写法）</span><br><span class="line">    ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    //借助mapGetters生成计算属性：bigSum（对象写法）</span><br><span class="line">    ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;),</span><br><span class="line"></span><br><span class="line">    //借助mapGetters生成计算属性：bigSum（数组写法）</span><br><span class="line">    ...mapGetters([&#x27;bigSum&#x27;])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">    //靠mapActions生成：incrementOdd、incrementWait（对象形式）</span><br><span class="line">    ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">    //靠mapActions生成：incrementOdd、incrementWait（数组形式）</span><br><span class="line">    ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">    //靠mapActions生成：increment、decrement（对象形式）</span><br><span class="line">    ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),</span><br><span class="line">    </span><br><span class="line">    //靠mapMutations生成：JIA、JIAN（对象形式）</span><br><span class="line">    ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h4 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h4><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JAVASCRIPT</span><br><span class="line"></span><br><span class="line">const countAbout = &#123;</span><br><span class="line">  namespaced:true,//开启命名空间</span><br><span class="line">  state:&#123;x:1&#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    bigSum(state)&#123;</span><br><span class="line">       return state.sum * 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const personAbout = &#123;</span><br><span class="line">  namespaced:true,//开启命名空间</span><br><span class="line">  state:&#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取state数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">//方式一：自己直接读取</span><br><span class="line">this.$store.state.personAbout.list</span><br><span class="line">//方式二：借助mapState读取：</span><br><span class="line">...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取getters数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">//方式一：自己直接读取</span><br><span class="line">this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]</span><br><span class="line">//方式二：借助mapGetters读取：</span><br><span class="line">...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;])</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用dispatch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">//方式一：自己直接dispatch</span><br><span class="line">this.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)</span><br><span class="line">//方式二：借助mapActions：</span><br><span class="line">...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">//方式一：自己直接commit</span><br><span class="line">this.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)</span><br><span class="line">//方式二：借助mapMutations：</span><br><span class="line">...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3></li><li><p>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</p></li><li><p>前端路由：key是路径，value是组件。</p></li></ol><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">//引入VueRouter</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">//引入Luyou 组件</span><br><span class="line">import About from &#x27;../components/About&#x27;</span><br><span class="line">import Home from &#x27;../components/Home&#x27;</span><br><span class="line"></span><br><span class="line">//创建router实例对象，去管理一组一组的路由规则</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;/about&#x27;,</span><br><span class="line">component:About</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;/home&#x27;,</span><br><span class="line">component:Home</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//暴露router</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h4><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h4 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h4><ol><li><p>配置路由规则，使用children配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;/about&#x27;,</span><br><span class="line">component:About,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;/home&#x27;,</span><br><span class="line">component:Home,</span><br><span class="line">children:[ //通过children配置子级路由</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;news&#x27;, //此处一定不要写：/news</span><br><span class="line">component:News</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;message&#x27;,//此处一定不要写：/message</span><br><span class="line">component:Message</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h4><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">$route.query.id</span><br><span class="line">$route.query.title</span><br></pre></td></tr></table></figure></li></ol><h4 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h4><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;/demo&#x27;,</span><br><span class="line">component:Demo,</span><br><span class="line">children:[</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;test&#x27;,</span><br><span class="line">component:Test,</span><br><span class="line">children:[</span><br><span class="line">&#123;</span><br><span class="line">                      name:&#x27;hello&#x27; //给路由命名</span><br><span class="line">path:&#x27;welcome&#x27;,</span><br><span class="line">component:Hello,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;hello&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h4><ol><li><p>配置路由，声明接收params参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;/home&#x27;,</span><br><span class="line">component:Home,</span><br><span class="line">children:[</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;news&#x27;,</span><br><span class="line">component:News</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">component:Message,</span><br><span class="line">children:[</span><br><span class="line">&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">path:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数</span><br><span class="line">component:Detail</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">$route.params.id</span><br><span class="line">$route.params.title</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h4><p> 作用：让路由组件更方便的收到参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">path:&#x27;detail/:id&#x27;,</span><br><span class="line">component:Detail,</span><br><span class="line"></span><br><span class="line">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span><br><span class="line">// props:&#123;a:900&#125;</span><br><span class="line"></span><br><span class="line">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span><br><span class="line">// props:true</span><br><span class="line"></span><br><span class="line">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span><br><span class="line">props(route)&#123;</span><br><span class="line">return &#123;</span><br><span class="line">id:route.query.id,</span><br><span class="line">title:route.query.title</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h4><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h4 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h4><ol><li><p>作用：不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">//$router的两个API</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">id:xxx,</span><br><span class="line">title:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.$router.replace(&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">id:xxx,</span><br><span class="line">title:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">this.$router.forward() //前进</span><br><span class="line">this.$router.back() //后退</span><br><span class="line">this.$router.go() //可前进也可后退</span><br></pre></td></tr></table></figure></li></ol><h4 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h4><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h4><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h4 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h4><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">//全局前置守卫：初始化时执行、每次路由切换前执行</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">console.log(&#x27;beforeEach&#x27;,to,from)</span><br><span class="line">if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制</span><br><span class="line">if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则</span><br><span class="line">next() //放行</span><br><span class="line">&#125;else&#123;</span><br><span class="line">alert(&#x27;暂无权限查看&#x27;)</span><br><span class="line">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">next() //放行</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//全局后置守卫：初始化时执行、每次路由切换后执行</span><br><span class="line">router.afterEach((to,from)=&gt;&#123;</span><br><span class="line">console.log(&#x27;afterEach&#x27;,to,from)</span><br><span class="line">if(to.meta.title)&#123; </span><br><span class="line">document.title = to.meta.title //修改网页的title</span><br><span class="line">&#125;else&#123;</span><br><span class="line">document.title = &#x27;vue_test&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>独享守卫:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">beforeEnter(to,from,next)&#123;</span><br><span class="line">console.log(&#x27;beforeEnter&#x27;,to,from)</span><br><span class="line">if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制</span><br><span class="line">if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;</span><br><span class="line">next()</span><br><span class="line">&#125;else&#123;</span><br><span class="line">alert(&#x27;暂无权限查看&#x27;)</span><br><span class="line">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">//进入守卫：通过路由规则，进入该组件时被调用</span><br><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line">//离开守卫：通过路由规则，离开该组件时被调用</span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h4><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history模式：<ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 - vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32 GPIO通用输入输出口</title>
      <link href="/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F-GPIO%E9%80%9A%E7%94%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8F%A3/"/>
      <url>/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F-GPIO%E9%80%9A%E7%94%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="GPIO通用输入输出口"><a href="#GPIO通用输入输出口" class="headerlink" title="GPIO通用输入输出口"></a>GPIO通用输入输出口</h1><p>可配置为8种输入输出模式</p><h2 id="STM32-GPIO模式："><a href="#STM32-GPIO模式：" class="headerlink" title="STM32 GPIO模式："></a>STM32 GPIO模式：</h2><p>当使用STM32系列微控制器的GPIO引脚时，您可以根据您的应用需求选择不同的GPIO模式。以下是对每个模式的更详细介绍：</p><ol><li><strong>输入模式</strong>：<ul><li><strong>浮空输入（Floating Input）</strong>：引脚未连接到任何电路。可以用于读取外部电平，但应注意，由于没有上拉或下拉电阻，引脚可能会受到噪声干扰。</li><li><strong>上拉输入（Input Pull-Up）</strong>：引脚通过内部上拉电阻连接到高电平。在没有外部连接时，引脚会保持高电平。通常用于按钮和开关的输入，以防止悬空电平。</li><li><strong>下拉输入（Input Pull-Down）</strong>：引脚通过内部下拉电阻连接到低电平。在没有外部连接时，引脚会保持低电平。与上拉输入类似，通常用于按钮和开关的输入。</li></ul></li><li><strong>输出模式</strong>：<ul><li><strong>通用推挽输出（General-Purpose Push-Pull Output）</strong>：引脚可以输出高电平或低电平。用于驱动外部数字电路。</li><li><strong>开漏输出（Open-Drain Output）</strong>：引脚只能拉低，而不能拉高。通常需要外部上拉电阻来拉高电平。用于实现开漏输出，适用于一些总线通信协议如I2C和SPI。</li><li><strong>复用开漏输出（Open-Drain Output with Alternate Function）</strong>：类似于开漏输出，但引脚还可以配置为执行特定的备用功能，如UART通信、PWM输出等。</li></ul></li><li><strong>复用模式</strong>：<ul><li>引脚可以配置为具有不同备用功能的引脚。这些备用功能可以通过相应的寄存器设置来选择，以满足特定的通信或控制需求。</li></ul></li><li><strong>模拟模式</strong>：<ul><li>GPIO引脚可以配置为模拟输入或模拟输出。模拟输入用于连接到模拟传感器或其他模拟电路，而模拟输出用于输出模拟信号。</li></ul></li><li><strong>中断模式</strong>：<ul><li>GPIO引脚可以配置为触发外部中断。当引脚状态变化时，可以触发中断服务程序，允许您在特定事件发生时立即响应。</li></ul></li><li><strong>高速模式</strong>：<ul><li>高速模式允许GPIO引脚以更高的时钟频率工作，以适应特定的应用需求。这对于需要快速切换引脚状态的应用非常有用。</li></ul></li><li><strong>低功耗模式</strong>：<ul><li>某些STM32系列支持低功耗模式，可以降低GPIO引脚的功耗，适用于需要长时间运行的电池供电应用。</li></ul></li></ol><p>引脚电平：0V~3.3V，部分引脚可容忍5V</p><p>输出模式下可控制端口输出高低电平，用以驱动LED，控制蜂鸣器、模拟通信协议输出时序等</p><p>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Analog IN 模拟输入,这些引脚通常用于连接到模拟传感器或其他模拟电路。</span></span><br><span class="line">GPIO_Mode_AIN = <span class="number">0x0</span>,</span><br><span class="line"><span class="comment">//In_Floating 浮空输入,这意味着引脚未连接到任何电路，可以读取外部电平，但可能受到噪声干扰。</span></span><br><span class="line">GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,</span><br><span class="line"><span class="comment">//In Pull Down 下拉输入,引脚通过内部下拉电阻连接到低电平，在没有外部连接时，引脚会保持低电平。</span></span><br><span class="line">GPIO_Mode_IPD = <span class="number">0x28</span>,</span><br><span class="line"><span class="comment">//In Pull Up 上拉输入,引脚通过内部上拉电阻连接到高电平，在没有外部连接时，引脚会保持高电平。</span></span><br><span class="line">GPIO_Mode_IPU = <span class="number">0x48</span>,</span><br><span class="line"><span class="comment">//Out Open Drain 开漏输出，高电平没有驱动能力,在这种模式下，引脚可以拉低，但不能拉高，通常需要外部上拉电阻来拉高电平。</span></span><br><span class="line">GPIO_Mode_Out_OD = <span class="number">0x14</span>,</span><br><span class="line"><span class="comment">//Out Push Pull 推挽输出，高低电平都有驱动能力,在这种模式下，引脚可以输出高电平或低电平，具有驱动能力，用于驱动外部数字电路。</span></span><br><span class="line">GPIO_Mode_Out_PP = <span class="number">0x10</span>,</span><br><span class="line"><span class="comment">//Atl Open Drain 复用开漏,类似于开漏输出，但引脚还可以配置为执行特定的备用功能，如UART通信、I2C通信等。</span></span><br><span class="line">GPIO_Mode_AF_OD = <span class="number">0x1C</span>,</span><br><span class="line"><span class="comment">//Atl Push Pull 复用推挽,类似于推挽输出，但引脚也可以配置为执行备用功能。</span></span><br><span class="line">GPIO_Mode_AF_PP = <span class="number">0x18</span></span><br></pre></td></tr></table></figure><h2 id="操作STM32的GPIO步骤"><a href="#操作STM32的GPIO步骤" class="headerlink" title="操作STM32的GPIO步骤"></a>操作STM32的GPIO步骤</h2><h3 id="1、使用RCC开启GPIO的时钟"><a href="#1、使用RCC开启GPIO的时钟" class="headerlink" title="1、使用RCC开启GPIO的时钟"></a>1、使用RCC开启GPIO的时钟</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数选择外设，第二个参数使能或失能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p>AHB外设时钟控制函数就是使能或者失能AHB外设时钟的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Enables or disables the AHB peripheral clock.</span></span><br><span class="line"><span class="comment">  使能或失能AHB外设时钟</span></span><br><span class="line"><span class="comment">  * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.</span></span><br><span class="line"><span class="comment">  *   第一个参数选择哪一个外设</span></span><br><span class="line"><span class="comment">  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination</span></span><br><span class="line"><span class="comment">  *   of the following values:</span></span><br><span class="line"><span class="comment">  stm32互联型的设备可以在这个列表选择</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_DMA2</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_SRAM</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_FLITF</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_CRC</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_OTG_FS    </span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_ETH_MAC   </span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_ETH_MAC_Tx</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_ETH_MAC_Rx</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *   For @b other_STM32_devices, this parameter can be any combination of the </span></span><br><span class="line"><span class="comment">  *   following values:   </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_DMA2</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_SRAM</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_FLITF</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_CRC</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_FSMC</span></span><br><span class="line"><span class="comment">  *     @arg RCC_AHBPeriph_SDIO</span></span><br><span class="line"><span class="comment">  *   </span></span><br><span class="line"><span class="comment">  * @note SRAM and FLITF clock can be disabled only during sleep make</span></span><br><span class="line"><span class="comment">  注意SRAM和FLITF时钟只能在睡眠时禁用</span></span><br><span class="line"><span class="comment">  * @param  NewState: new state of the specified peripheral clock.</span></span><br><span class="line"><span class="comment">  指定外设时钟的新状态。</span></span><br><span class="line"><span class="comment">  *   This parameter can be: ENABLE or DISABLE.</span></span><br><span class="line"><span class="comment">  取值为:ENABLE或DISABLE。</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    RCC-&gt;AHBENR |= RCC_AHBPeriph;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    RCC-&gt;AHBENR &amp;= ~RCC_AHBPeriph;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用GPIO-Init函数初始化GPIO"><a href="#2、使用GPIO-Init函数初始化GPIO" class="headerlink" title="2、使用GPIO_Init函数初始化GPIO"></a>2、使用GPIO_Init函数初始化GPIO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数用于将指定的GPIO外设复位为其默认状态。</span></span><br><span class="line"><span class="comment">//参数 GPIOx 是一个指向 GPIO_TypeDef 结构的指针，用于指定要复位的GPIO外设，例如 GPIOA、GPIOB等。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//该函数用于将AFIO (Alternate Function I/0) 外设复位为其认状态。AFIO设用于配器GPIO引脚的复用功能。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//该函数用于通过结构体参数初始化指定GPIO外设的GPIO引脚。</span></span><br><span class="line"><span class="comment">//参数 GPIOx 是一个指向 GPIO_TypeDef 结构的指针，用于指定要配置的GPIO外设</span></span><br><span class="line"><span class="comment">//参数 GPIO Initstruct 是一个结构体指针，包含有关要配置的GPIO引脚的详细信息，例如引脚的模式速度、上下拉等。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">//该函数用于将传递的结构体初始化为默认值，以便稍后通过 GPIO_Init 函数进行配置//参数 GPIO_Initstruct 是一个结构体指针，需要在调用该函数前进行定义，并将其传递给 GPIO_Init函数。</span></span><br><span class="line"><span class="type">void</span> pIO <span class="title function_">structInit</span><span class="params">(GPIO InitTypeDef* GPIO Initstruct)</span>;<span class="comment">//该函数用于读取指</span></span><br></pre></td></tr></table></figure><h3 id="3、使用输出或输入的函数控制GPIO"><a href="#3、使用输出或输入的函数控制GPIO" class="headerlink" title="3、使用输出或输入的函数控制GPIO"></a>3、使用输出或输入的函数控制GPIO</h3><h4 id="3-1、输出函数控制GPIO"><a href="#3-1、输出函数控制GPIO" class="headerlink" title="3.1、输出函数控制GPIO"></a>3.1、输出函数控制GPIO</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIO的写入输出函数</span></span><br><span class="line"><span class="comment">//该函数用于将指定GPIO外设的一个或多个引脚设置为高电平。</span></span><br><span class="line"><span class="type">void</span> GPIO <span class="title function_">SetBits</span><span class="params">(GPIO TypeDef* GPIOx, uint16 t GPIO Pin)</span>;</span><br><span class="line"><span class="comment">//该函数用于将指定GPIO外设的一个或多个引脚设置为低电平。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//该函数用于根据第三个参数的值来设置指定GPIO外设的一个引脚的状态（高或低）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;</span><br><span class="line"><span class="comment">//该函数用于根据第二个参数的值来设置指定GPIO外设的所有引脚的状态（高或低）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br></pre></td></tr></table></figure><h4 id="3-2、输出函数控制GPIO"><a href="#3-2、输出函数控制GPIO" class="headerlink" title="3.2、输出函数控制GPIO"></a>3.2、输出函数控制GPIO</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIO的读取输入函数</span></span><br><span class="line"><span class="comment">//该函数用于读取指定GPIO外设的单个引脚的输入状态，返回引脚的状态(高电平或低电平</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GpIO_TypeDef* GPIOx, uint16 t GpIO Pin)</span>;</span><br><span class="line"><span class="comment">//该函数用于读取指定GPIO外设的所有引脚的输入状态，返回整个GPIO端口的状态值。</span></span><br><span class="line">uint16 t GPIO <span class="title function_">ReadInputData</span><span class="params">(GPIO TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//该函数用于读取指定GPI外设的单个引脚的输出状态，返回引脚的状态《高电平或低电平)</span></span><br><span class="line">uint8 t GPIO <span class="title function_">ReadOutputDataBit</span><span class="params">(GpIO TypeDef* GPIOx, uint16 t GpIO pin)</span>;</span><br><span class="line"><span class="comment">//该函数用于读取指定GPIO外设的所有引脚的输出状态，返回整个GPIO端口的状态值。</span></span><br><span class="line">uint16 t GPIO <span class="title function_">ReadoutputData</span><span class="params">(GpIO TypeDef* GPIOx)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32f103c8t6介绍</title>
      <link href="/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F-stm32f103c8t6/"/>
      <url>/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F-stm32f103c8t6/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32f103c8t6"><a href="#stm32f103c8t6" class="headerlink" title="stm32f103c8t6"></a>stm32f103c8t6</h1><p>STM32F103C8T6是STMicroelectronics（意法半导体）推出的一款STM32系列微控制器（MCU）的型号。这款微控制器基于ARM Cortex-M3内核，并具有丰富的外设和功能，适用于各种嵌入式系统和应用。</p><p>以下是关于STM32F103C8T6微控制器的一些主要特征和规格：</p><ol><li><p><strong>处理器核心</strong>：</p><ul><li>ARM Cortex-M3内核，工作频率通常为72 MHz。</li></ul></li><li><p><strong>闪存和RAM</strong>：</p><ul><li>64KB Flash存储器：用于程序存储。</li><li>20KB SRAM：用于数据存储。</li></ul></li><li><p><strong>GPIO引脚</strong>：</p><ul><li>支持多个GPIO引脚，可以配置为不同的输入/输出模式，包括浮空输入、上拉/下拉输入、推挽输出、开漏输出等。</li></ul></li><li><p><strong>通信接口</strong>：</p><ul><li>USART/UART：用于串口通信。</li><li>SPI：用于串行外设接口。</li><li>I2C：用于两线制串行通信。</li><li>CAN：用于控制器局域网通信。</li></ul></li><li><p><strong>定时器</strong>：</p><ul><li>通用定时器：支持多个通用定时器，可用于生成脉冲、计时和PWM输出。</li><li>基本定时器：支持基本定时器功能。</li><li>看门狗定时器：用于系统复位和监视。</li></ul></li><li><p><strong>ADC</strong>：</p><ul><li>内置模数转换器（ADC）：用于模拟信号采样。</li></ul></li><li><p><strong>中断和DMA</strong>：</p><ul><li>支持中断控制器，可用于处理各种事件和中断。</li><li>支持直接存储器访问控制器（DMA），可用于高速数据传输。</li></ul></li><li><p><strong>电源管理</strong>：</p><ul><li>支持低功耗模式，可实现能效优化。</li><li>内置复位和电压监视电路。</li></ul></li><li><p><strong>包装</strong>：</p><ul><li>LQFP48封装，带有48个引脚。</li></ul></li><li><p><strong>工作电压</strong>：</p><ul><li>典型工作电压为3.3V。</li></ul></li><li><p><strong>应用领域</strong>：</p><ul><li>STM32F103C8T6常用于各种嵌入式系统，包括自动控制、传感器接口、通信接口、工业控制、家用电器、嵌入式网络等领域。</li></ul></li></ol><p>STM32F103C8T6是一款功能强大的微控制器，具有广泛的外设和通信接口，适用于多种应用场景。开发人员可以使用STMicroelectronics提供的开发工具，如STM32CubeMX和STM32CubeIDE，来开发和编程STM32F103C8T6微控制器。此外，还可以利用各种外部传感器和模块来扩展其功能。</p><h2 id="1、stm32f103c8t6片上资源外设"><a href="#1、stm32f103c8t6片上资源外设" class="headerlink" title="1、stm32f103c8t6片上资源外设"></a>1、stm32f103c8t6片上资源外设</h2><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/stm32about1.png" alt="1"></p><h2 id="2、STM32系列产品命名规则"><a href="#2、STM32系列产品命名规则" class="headerlink" title="2、STM32系列产品命名规则"></a>2、STM32系列产品命名规则</h2><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/stm32about2.png" alt=""></p><h2 id="3、stm32f103c8t6引脚定义"><a href="#3、stm32f103c8t6引脚定义" class="headerlink" title="3、stm32f103c8t6引脚定义"></a>3、stm32f103c8t6引脚定义</h2><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/STM32F103C8T6%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89.png" alt="STM32F103C8T6引脚定义"></p>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git全面教程——git远程仓库！！！</title>
      <link href="/2023/09/03/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2023/09/03/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p><p>可是有用过<strong>集中式版本控制系统SVN</strong>的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p><p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：<strong>远程仓库</strong>。</p><p>Git是分布式版本控制系统，同一个Git仓库，可以<strong>分布到不同的机器上</strong>。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以<strong>免费获得Git远程仓库</strong>。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><ul><li><strong>第1步</strong>：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><ul><li><strong>第2步</strong>：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</li></ul><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitwarehouse1.jpg" alt="1"></p><p>点“Add Key”，你就应该看到已经添加的Key：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitwarehouse2.jpg" alt="2"></p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p><p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitwarehouse7.jpg" alt="3"></p><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitwarehouse3.jpg" alt="4"></p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitwarehouse4.jpg" alt="5"></p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h2 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h2><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h1 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h1><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitwarehouse5.jpg" alt="6"></p><p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitwarehouse6.jpg" alt="7"></p><p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into &#x27;gitskills&#x27;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>]]></content>
      
      
      <categories>
          
          <category> 学习技能 </category>
          
          <category> git全面教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git全面教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git全面教程——使用！！！</title>
      <link href="/2023/08/30/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/08/30/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>现在，运行<code>git status</code>命令看看结果：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add distributed&quot;</span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p></li><li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p></li></ul><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>然后尝试提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><ul><li>版本1：wrote a readme file</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><ul><li>版本2：add distributed</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><ul><li>版本3：append GPL</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gituse1.jpg" alt="1"></p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──▶ ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──▶ ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>现在总结一下：</p><ul><li><p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p></li><li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p></li><li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p></li></ul><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>先来看名词解释。</p><h2 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h2><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gituse2.jpg" alt="2"></p><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gituse3.jpg" alt="3"></p><p>分支和<code>HEAD</code>的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><ul><li><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p></li><li><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p></li></ul><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   LICENSE</span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gituse4.jpg" alt="4"></p><p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gituse5.jpg" alt="5"></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p><p>没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。</p><h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure><p>然后，添加：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>然后，再修改readme.txt：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;git tracks changes&quot;</span><br><span class="line">[master 519219b] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>提交后，再看看状态：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>咦，怎么第二次的修改没有被提交？</p><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>可见，第二次修改确实没有被提交。</p><p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><p>好，现在，把第二次修改提交了，然后开始小结。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mreadme.txt</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>整个世界终于清静了！</p><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>现在，文件就从版本库中被删除了。</p><p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习技能 </category>
          
          <category> git全面教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git全面教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系架构知识点总结</title>
      <link href="/2023/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm/"/>
      <url>/2023/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-arm/</url>
      
        <content type="html"><![CDATA[<h2 id="1-硬件基础"><a href="#1-硬件基础" class="headerlink" title="1.硬件基础"></a>1.硬件基础</h2><h3 id="1-1-CPU、MPU、MCU、SOC、SOPC联系与差别？"><a href="#1-1-CPU、MPU、MCU、SOC、SOPC联系与差别？" class="headerlink" title="1.1 CPU、MPU、MCU、SOC、SOPC联系与差别？"></a>1.1 CPU、MPU、MCU、SOC、SOPC联系与差别？</h3><ol><li><p><strong>CPU（Central Processing Unit）</strong></p><p> CPU是一台计算机的<strong>运算核心和控制核心</strong>。CPU由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。差不多所有的CPU的运作原理可分为四个阶段：提取（Fetch）、解码（Decode）、执行（Execute）和写回（Writeback）。CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对CPU的编程。</p></li><li><p><strong>MPU(Micro Processor Unit)</strong></p><p> MPU叫<strong>微处理器</strong>（不是微控制器），通常代表一个<strong>功能强大的CPU</strong>（暂且理解为<strong>增强版的CPU</strong>吧）,但不是为任何已有的特定计算目的而设计的芯片。这种芯片往往是个人计算机和高端工作站的核心CPU。最常见的微处理器是Motorola的68K系列和Intel的X86系列。</p></li><li><p><strong>MCU(Micro Control Unit)</strong></p><p> MCU叫微控制器，是指随着大规模集成电路的出现及其发展，将<strong>计算机的CPU、RAM、ROM、定时计数器和多种I/O接口集成在一片芯片上</strong>，形成芯片级的芯片，比如51，avr这些芯片，内部<strong>除了CPU外还有RAM,ROM,可以直接加简单的外围器件</strong>（电阻，电容）就可以运行代码了，而MPU如x86，arm这些就不能直接放代码了，它只不过是增强版的CPU，所以得添加RAM,ROM。MCUMPU最主要的区别就睡能否直接运行代码。MCU有内部的RAMROM，而MPU是增强版的CPU，需要添加外部RAMROM才可以运行代码。</p></li><li><p><strong>SOC（Systemon Chip）</strong></p><p> SOC指的是片上系统，MCU只是<strong>芯片级</strong>的芯片，而<strong>SOC是系统级的芯片</strong>，它既MCU（51，avr）那样有内置RAM,ROM同时又像MPU（arm）那样强大的，不单单是放简单的代码，可以放系统级的代码，也就是说可以<strong>运行操作系统</strong>（将就认为是MCU集成化与MPU强处理力各优点二合一）。</p></li><li><p><strong>SOPC（System On a Programmable Chip）</strong></p><p> SOPC可编程片上系统（FPGA就是其中一种），上面4点的硬件配置是固化的，就是说51单片机就是51单片机，不能变为avr，而avr就是avr不是51单片机，他们的硬件是一次性掩膜成型的，能改的就是软件配置，说白点就是改代码，本来是跑流水灯的，改下代码，变成数码管，而SOPC则是<strong>硬件配置，软件配置都可以修改</strong>，软件配置跟上面一样，没什么好说的，至于硬件，是可以自己构建的也就是说这个芯片是自己构造出来的，<strong>这颗芯片我们叫“白片”</strong>，什么芯片都不是，把<strong>硬件配置信息下载进去了，他就是相应的芯片了</strong>，可以让他变成51，也可以是avr，甚至arm，同时SOPC是在SOC基础上来的，所以他也是系统级的芯片，所以记得当把他变成arm时还得加外围ROM，RAM之类的，不然就是MPU了。</p></li></ol><h3 id="1-2-交叉编译器是什么？为什么需要交叉编译器？"><a href="#1-2-交叉编译器是什么？为什么需要交叉编译器？" class="headerlink" title="1.2 交叉编译器是什么？为什么需要交叉编译器？"></a>1.2 交叉编译器是什么？为什么需要交叉编译器？</h3><ol><li><p><strong>在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码</strong>，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码。</p></li><li><p>这里需要注意的是所谓平台，实际上包含两个概念：<strong>体系结构（Architecture）、操作系统（Operating System）</strong>。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和WindowsNT for x86操作系统的简称。</p></li><li><p>有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又<strong>需要这个编译器的某些特征</strong>；有时是因为目的平台上的<strong>资源贫乏</strong>，无法运行我们所需要编译器；有时又是因为目的<strong>平台还没有建立</strong>，连操作系统都没有，根本谈不上运行什么编译器。</p></li></ol><h3 id="1-3-描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？"><a href="#1-3-描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？" class="headerlink" title="1.3 描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？"></a>1.3 描述一下嵌入式基于ROM的运行方式和基于RAM的运行方式有什么区别？</h3><p>基于RAM</p><ol><li><p>需要把硬盘和其他介质的代码先加载到ram中，加载过程中一般有<strong>重定位</strong>的操作。</p></li><li><p><strong>速度比基于ROM的快，可用RAM比基于ROM的少</strong>，因为所有的代码，数据都必须存放在RAM中。</p></li></ol><p>基于ROM</p><ol><li><p><strong>速度较基于RAM的慢</strong>，因为会有一个把变量，部分代码等从存储器（硬盘，flash）搬移到RAM的过程。</p></li><li><p><strong>可用RAM资源比基于RAM的多</strong></p></li></ol><h2 id="2-ARM处理器"><a href="#2-ARM处理器" class="headerlink" title="2.ARM处理器"></a>2.ARM处理器</h2><h3 id="2-1-什么是哈佛结构和冯诺依曼结构？"><a href="#2-1-什么是哈佛结构和冯诺依曼结构？" class="headerlink" title="2.1 什么是哈佛结构和冯诺依曼结构？"></a>2.1 什么是哈佛结构和冯诺依曼结构？</h3><p>定义：冯诺依曼结构釆用指令和数据<strong>统一编址</strong>，使用<strong>同条总线</strong>传输，CPU读取指令和数据的操作<strong>无法重叠</strong>。哈佛结构釆用指令和数据<strong>独立编址</strong>，使用<strong>两条独立的总线传输</strong>，CPU读取指令和数据的操作<strong>可以重叠</strong>。</p><p>利弊：冯诺依曼结构主要用于<strong>通用计算机领域</strong>，需要对存储器中的代码和数据频繁的进行修改，统一编址有利于<strong>节约资源</strong>。哈佛结构主要用于<strong>嵌入式计算机</strong>，程序固化在硬件中，有较高的<strong>可靠性、运算速度和较大的吞吐量</strong>。</p><h3 id="2-2-什么是ARM流水线技术？"><a href="#2-2-什么是ARM流水线技术？" class="headerlink" title="2.2 什么是ARM流水线技术？"></a>2.2 什么是ARM流水线技术？</h3><ol><li><p>流水线技术通过<strong>多个功能部件并行</strong>工作来<strong>缩短程序执行时间</strong>，提高处理器核的<strong>效率和吞吐率</strong>，从而成为微处理器设计中最为重要的技术之一。ARM7处理器核使用了典型<strong>三级流水线的冯·诺伊曼结构</strong>，ARM9系列则采用了基于<strong>五级流水线的哈佛结构</strong>。通过增加流水线级数简化了流水线各级的逻辑，进一步提高了处理器的性能。</p></li><li><p>PC代表<strong>程序计数器</strong>，流水线使用三个阶段，因此指令分为三个阶段执行：1.<strong>取指</strong>（从存储器装载一条指令）；2.<strong>译码</strong>（识别将要被执行的指令）；3.<strong>执行</strong>（处理指令并将结果写回寄存器）。而<strong>R15（PC）总是指向“正在取指”的指令</strong>，而不是指向“正在执行”的指令或正在“译码”的指令。一般来说，人们习惯性约定将“正在执行的指令作为参考点”，称之为当前第一条指令，因此<strong>PC总是指向第三条指令</strong>。当ARM状态时，每条指令为4字节长，所以PC始终指向该指令地址加8字节的地址，即：<strong>PC值=当前程序执行位置+8</strong>；</p></li><li><p>ARM指令是三级流水线，取指，译指，执行，同时执行的，现在PC指向的是正在取指的地址（下一条指令），那么<strong>cpu正在译指的指令地址是PC-4</strong>（假设在ARM状态下，一个指令占4个字节），<strong>cpu正在执行的指令地址是PC-8</strong>，也就是说PC所指向的地址和现在所执行的指令地址相差8。当突然发生中断的时候，保存的是PC的地址（PC-8+4=<strong>PC-4</strong>下一条指令的地址）。这样你就知道了，<strong>如果返回的时候返回PC，那么中间就有一个指令没有执行</strong>，所以用<code>SUB pc lr-irq</code></p><p> <img src="https://tuchuang.voooe.cn/images/2023/03/05/ARM7025050fed1ab1a6.png" alt="https://tuchuang.voooe.cn/images/2023/03/05/ARM7025050fed1ab1a6.png"></p></li></ol><h3 id="2-3-ARM有几种工作模式？"><a href="#2-3-ARM有几种工作模式？" class="headerlink" title="2.3 ARM有几种工作模式？"></a>2.3 ARM有几种工作模式？</h3><ol><li><p><strong>用户模式(USR)</strong></p><p> 用户模式是用户程序的工作模式，它运行在操作系统的用户态，它<strong>没有权限去操作其它硬件资源</strong>，只能执行处理自己的数据，也<strong>不能切换到其它模式下</strong>，要想访问硬件资源或切换到其它模式只能通过<strong>软中断或产生异常</strong>。</p></li><li><p><strong>系统模式(SYS)</strong></p><p> 系统模式是<strong>特权模式</strong>，不受用户模式的限制。用户模式和系统模式共用一套寄存器，操作系统在该模式下可以方便的访问用户模式的寄存器，而且操作系统的一些特权任务可以使用这个模式<strong>访问一些受控的资源</strong>。</p><blockquote><p>说明：用户模式与系统模式两者<strong>使用相同的寄存器</strong>，都没有SPSR（Saved Program Statement Register，已保存程序状态寄存器），但系统模式比用户模式有更高的权限，可以访问所有系统资源。</p></blockquote></li><li><p><strong>一般中断模式(IRQ)</strong></p><p> 一般中断模式也叫普通中断模式，用于处理一般的中断请求，通常在硬件<strong>产生中断信号之后自动进入</strong>该模式，该模式为特权模式，可以<strong>自由访问系统硬件资源</strong>。</p></li><li><p><strong>快速中断模式(FIQ)</strong></p><p> 快速中断模式是相对一般中断模式而言的，它是用来处理<strong>对时间要求比较紧急的中断请求</strong>，主要用于高速数据传输及通道处理中。（快中断有许多（R8~R14）自己的专用寄存器，发生中断时，使用自己的寄存器就避免了保存和恢复某些寄存器。如果异常中断处理程序中使用它自己的物理寄存器之外的其他寄存器，异常中断处理程序必须保存和恢复这些寄存器）</p></li><li><p><strong>管理模式（SVC）</strong></p><p> 管理模式是<strong>CPU上电后默认模式</strong>，因此，在该模式下主要用来做<strong>系统的初始化</strong>，软中断处理也在该模式下。当用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式。</p><blockquote><p>说明：系统复位或开机、软中断时进入到SVC模式下。</p></blockquote></li><li><p><strong>终止模式(ABT)</strong></p><p> 中止模式用于支持虚拟内存或存储器保护，当用户程序<strong>访问非法地址，没有权限读取的内存地址</strong>时，会进入该模式，linux下编程时经常出现的segment fault通常都是在该模式下抛出返回的。</p></li><li><p><strong>未定义模式(UND)</strong></p><p> 未定义模式用于支持硬件协处理器的软件仿真，CPU在指令的译码阶段不能识别该指令操作时，会进入未定义模式。</p></li></ol><p><strong>注意：</strong></p><ol><li><p><strong>除了用户模式外</strong>，其它6种模式称为特权模式。所谓特权模式，即具有如下权利：</p><p> a.MRS（把状态寄存器的内容放到通用寄存器）；</p><p> b.MSR（把通用寄存器的内容放到状态寄存器中）。</p><p> 由于状态寄存器中的内容不能够改变，因此，要先把内容复制到通用寄存器中，然后修改通用寄存器中的内容，再把通用寄存器中的内容复制给状态寄存器中，即可完成“修改状态寄存器”的任务。</p></li><li><p>剩下的六种模式中<strong>除去系统模式</strong>外，统称为异常模式。</p></li></ol><h3 id="2-4-Arm有多少32位寄存器？"><a href="#2-4-Arm有多少32位寄存器？" class="headerlink" title="2.4 Arm有多少32位寄存器？"></a>2.4 Arm有多少32位寄存器？</h3><p>ARM处理器共有37个寄存器。它包含<strong>31个通用寄存器和6个状态寄存器</strong>。</p><h3 id="2-5-ARM指令集分为几类？"><a href="#2-5-ARM指令集分为几类？" class="headerlink" title="2.5 ARM指令集分为几类？"></a>2.5 ARM指令集分为几类？</h3><p>2类，分别为Thumb指令集，ARM指令集。<strong>ARM指令长度为32位，Thumb指令长度为16位</strong>。这种特点<br>使得ARM既能执行16位指令，又能执行32位指令，从而增强了ARM内核的功能。</p><h3 id="2-6-通用寄存器包括R0～R15，可以分为具体哪三类？"><a href="#2-6-通用寄存器包括R0～R15，可以分为具体哪三类？" class="headerlink" title="2.6 通用寄存器包括R0～R15，可以分为具体哪三类？"></a>2.6 通用寄存器包括R0～R15，可以分为具体哪三类？</h3><p>通用寄存器包括R0-R15，可以分为3类：</p><ol><li><p><strong>未分组寄存器R0-R7</strong></p><p> 在所有运行模式下，未分组寄存器都指向<strong>同一个物理寄存器</strong>，他们未被系统用作特殊的用途。因此在中断或<strong>异常处理</strong>进行异常模式转换时，由于不同的处理器运行模式均使用相同的物理寄存器，所以<strong>可能造成寄存器中数据的破坏</strong>。</p></li><li><p><strong>分组寄存器R8-R14</strong></p><p> 对于分组寄存器，他们每次所访问的物理寄存器都<strong>与当前的处理器运行模式相关</strong>。R13常用作存放堆栈指针，用户也可以使用其他寄存器存放堆栈指针，但在Thumb指令集下，某些指令强制要求使用R13存放堆栈指针。R14称为链接寄存器（LR，Link Register），当执行子程序时，R14可得到R15（PC）的备份，执行完子程序后，又将R14的值复制回PC，即使用R14保存返回地址。</p></li><li><p><strong>程序计数器PC（R15）</strong></p><p> 寄存器R15用作程序计数器（PC），在ARM状态下，位[1:0]为0，位[31:2]用于保存PC；在Thumb状态下,位[0]为0，位[31:1]用于保存PC。</p></li></ol><p>ARM系统中，在函数调用的时候，参数是通过哪种方式传递的？</p><p>当参数小于等于4的时候是通过<strong>r0-r3</strong>寄存器来进行传递的，当参数大于4的时候是通过<strong>压栈</strong>的方式进行传递。</p><h3 id="2-7-ARM处理器有几种工作状态？"><a href="#2-7-ARM处理器有几种工作状态？" class="headerlink" title="2.7 ARM处理器有几种工作状态？"></a>2.7 ARM处理器有几种工作状态？</h3><p>从编程的角度来看，ARM微处理器的工作状态一般ARM和Thumb有两种，并可在两种状态之间切换。</p><ol><li><p>ARM状态：此时处理器执行32位的字对齐ARM指令，绝大部分工作在此状态。</p></li><li><p>Thumb状态：此时处理器执行16位的半字对齐的Thumb指令。</p></li></ol><h3 id="2-8-ARM协处理器指令包括哪3类，请描述它们的功能？"><a href="#2-8-ARM协处理器指令包括哪3类，请描述它们的功能？" class="headerlink" title="2.8 ARM协处理器指令包括哪3类，请描述它们的功能？"></a>2.8 ARM协处理器指令包括哪3类，请描述它们的功能？</h3><ol><li><p>用于ARM处理器<strong>初始化</strong>ARM协处理器的数据处理操作。</p></li><li><p>用于ARM处理器的<strong>寄存器和ARM协处理器</strong>的寄存器间的<strong>数据传送</strong>操作。</p></li><li><p>用于在ARM协处理器的<strong>寄存器和内存单元</strong>之间传送数据。</p></li></ol><h3 id="2-9-什么是PLL（锁相环）？"><a href="#2-9-什么是PLL（锁相环）？" class="headerlink" title="2.9 什么是PLL（锁相环）？"></a>2.9 什么是PLL（锁相环）？</h3><p>简单来说，输入时钟的存在是作为“参考源”。锁相环<strong>不是为了单纯产生同频同相信号，而是一般集成进某种“频率综合电路”，产生一个不同频，但锁相的信号</strong>。有点绕，打个比方：某参考晶振10Mhz，频率综合器A使用该参考源产生了900Mhz时钟，而频率综合器B产生了1Ghz时钟。虽然两路频率不同，但<strong>由于使用的通一个参考源，他们俩仍然是同源信号</strong>。相反，如果不同源，那么即便同频他们也不可能一致，因为世界上没有两个钟能做到完全一样，总有微弱的频差，导致相位飘移。在很多现实应用中有要求同源时钟的场合，所以，锁相环被广泛应用。锁相环的另外一项衍生应用是<strong>相干解调</strong>。</p><h2 id="3-中断与异常"><a href="#3-中断与异常" class="headerlink" title="3.中断与异常"></a>3.中断与异常</h2><h3 id="3-1-中断与异常有何区别？"><a href="#3-1-中断与异常有何区别？" class="headerlink" title="3.1 中断与异常有何区别？"></a>3.1 中断与异常有何区别？</h3><p><strong>中断</strong>是指<strong>外部硬件</strong>产生的一个电信号从CPU的中断引脚进入，打断CPU的运行。</p><p><strong>异常</strong>是指软件运行过程中发生了一些<strong>必须作出处理</strong>的事件，CPU自动产生一个陷入来打断CPU的运行。异常在处理的时候必须考虑与处理器的<strong>时钟同步</strong>，实际上异常也称为同步中断，在处理器执行到因编译错误而导致的错误指令时，或者在执行期间出现特殊错误，<strong>必须靠内核处理</strong>的时候，处理器就会产生一个异常。</p><h3 id="3-2-中断与DMA有何区别？"><a href="#3-2-中断与DMA有何区别？" class="headerlink" title="3.2 中断与DMA有何区别？"></a>3.2 中断与DMA有何区别？</h3><p><strong>DMA</strong></p><p>是一种<strong>无须CPU参与</strong>，就可以让<strong>外设与系统内存</strong>之间进行双向数据传输的硬件机制，使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而<strong>大大提高系统的吞吐率</strong>。</p><p><strong>中断</strong></p><p>是指CPU在执行程序的过程中，出现了某些突发事件时，CPU<strong>必须暂停执行当前的程序</strong>，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。</p><p>区别：<strong>DMA不需CPU参与，而中断需要CPU参与</strong>。</p><h3 id="3-3-中断能不能睡眠，为什么？下半部能不能睡眠？"><a href="#3-3-中断能不能睡眠，为什么？下半部能不能睡眠？" class="headerlink" title="3.3 中断能不能睡眠，为什么？下半部能不能睡眠？"></a>3.3 中断能不能睡眠，为什么？下半部能不能睡眠？</h3><ol><li><p>中断处理的时候，不应该发生进程切换。因为在中断上下文中，唯一能打断当前中断handler的<strong>只有更高优先级的中断，它不会被进程打断</strong>。如果在中断上下文中休眠，则没有办法唤醒它，因为所有的wake_up_xxx都是针对某个进程而言的，而在中断上下文中，没有进程的概念，没有一个task_struct（这点对于softirq和tasklet一样）。因此真的休眠了，比如调用了会导致阻塞的例程，<strong>内核几乎肯定会死</strong>。</p></li><li><p>schedule()在切换进程时，保存当前的进程上下文（CPU寄存器的值、进程的状态以及堆栈中的内容），以便以后恢复此进程运行。中断发生后，内核会先保存当前被中断的进程上下文（在调用中断处理程序后恢复）。但<strong>在中断处理程序里，CPU寄存器的值肯定已经变化了</strong>（最重要的程序计数器PC、堆栈SP等）。如果此时因为睡眠或阻塞操作调用了schedule()，则保存的进程上下文就不是当前的进程上下文了。所以，<strong>不可以在中断处理程序中调用schedule()</strong>。</p></li><li><p>2.4内核中schedule()函数本身在<strong>进来的时候判断是否处于中断上下文</strong>。因此，强行调用schedule()的结果就是内核BUG，但看2.6.18的内核schedule()的实现却没有这句，改掉了。</p></li></ol><pre><code>C</code></pre><ol><li><p>中断handler会使用被中断的进程内核堆栈，但不会对它有任何影响，因为handler使用完后会<strong>完全清除它使用的那部分堆栈</strong>，恢复被中断前的原貌。</p></li><li><p>处于中断上下文时候，<strong>内核是不可抢占</strong>的。因此，如果休眠，则内核一定挂起。</p></li></ol><h3 id="3-4-中断的响应执行流程是什么？"><a href="#3-4-中断的响应执行流程是什么？" class="headerlink" title="3.4 中断的响应执行流程是什么？"></a>3.4 中断的响应执行流程是什么？</h3><p>中断的响应流程：<strong>cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半部-&gt;恢复中断上下文</strong>。</p><h3 id="3-5-当一个异常出现以后，ARM微处理器会执行哪几步操作？"><a href="#3-5-当一个异常出现以后，ARM微处理器会执行哪几步操作？" class="headerlink" title="3.5 当一个异常出现以后，ARM微处理器会执行哪几步操作？"></a>3.5 当一个异常出现以后，ARM微处理器会执行哪几步操作？</h3><ol><li><p>将下一条指令的地址存入相应<strong>连接寄存器LR</strong>，以便程序在处理异常返回时能从正确的位置重新开始执行。若异常是从<strong>ARM状态</strong>进入，则LR寄存器中保存的是<strong>下一条指令的地址</strong>（当前PC＋4或PC＋8，与异常的类型有关）；若异常是从<strong>Thumb状态</strong>进入，则在LR寄存器中保存<strong>当前PC的偏移量</strong>，这样，异常处理程序就不需要确定异常是从何种状态进入的。例如：在软件中断异常SWI，指令MOVPC，R14_svc总是返回到下一条指令，不管SWI是在ARM状态执行，还是在Thumb状态执行。</p></li><li><p>将CPSR(程序状态寄存器 current program status register)<strong>复制</strong>到相应的SPSR中。</p></li><li><p>根据异常类型，强制<strong>设置CPSR的运行模式位</strong>。</p></li><li><p>强制PC从相关的异常向量地址取下一条指令执行，从而<strong>跳转到相应的异常处理程序</strong>处。</p></li></ol><h3 id="3-6-写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？"><a href="#3-6-写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？" class="headerlink" title="3.6 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？"></a>3.6 写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？</h3><ol><li><p>写一个中断服务程序要注意<strong>快进快出</strong>，在中断服务程序里面尽量<strong>快速采集信息</strong>，包括硬件信息，然后退出中断，要做其它事情可以使用<strong>工作队列</strong>或者<strong>tasklet</strong>方式。也就是中断上半部和下半部。</p></li><li><p>中断服务程序中<strong>不能有阻塞操作</strong>。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作。</p></li><li><p>中断服务程序<strong>注意返回值</strong>，要用操作系统定义的宏做为返回值，而不是自己定义的。</p></li><li><p>如果要做的事情较多，应将这些任务放在<strong>后半段</strong>(tasklet，等待队列等)处理。</p></li></ol><h3 id="3-7-为什么FIQ比IRQ要快？"><a href="#3-7-为什么FIQ比IRQ要快？" class="headerlink" title="3.7 为什么FIQ比IRQ要快？"></a>3.7 为什么FIQ比IRQ要快？</h3><ol><li><p>ARM的FIQ模式提供了<strong>更多的banked寄存器</strong>，r8到r14还有SPSR，而IRQ模式就没有那么多，R8,R9,R10,R11,R12对应的banked的寄存器就没有，这就意味着在ARM的IRQ模式下，中断处理程序<strong>自己要保存R8到R12这几个寄存器</strong>，然后退出中断处理时程序要<strong>恢复这几个寄存器</strong>，而FIQ模式由于这几个寄存器都有banked寄存器，模式切换时CPU<strong>自动保存</strong>这些值到banked寄存器，退出FIQ模式时<strong>自动恢复</strong>，所以这个过程FIQ比IRQ快.不要小看这几个寄存器，ARM在编译的时候，如果你FIQ中断处理程序足够用这几个独立的寄存器来运作，它就不<strong>会进行通用寄存器的压栈</strong>，这样也省了一些时间。</p></li><li><p>FIQ比IRQ有<strong>更高优先级</strong>，如果FIQ和IRQ同时产生，那么FIQ先处理。</p></li><li><p>在symbian系统里，当CPU处于FIQ模式处理FIQ中断的过程中，预取指令异常，未定义指令异常，软件中断全被禁止，所有的中断被屏蔽。所以FIQ就会很快执行，<strong>不会被其他异常或者中断打断</strong>，所以它又比IRQ快了。而IRQ不一样，当ARM处理IRQ模式处理IRQ中断时，如果来了一个FIQ中断请求，那正在执行的IRQ中断处理程序会被抢断，ARM切换到FIQ模式去执行这个FIQ，所以FIQ比IRQ快多了。</p></li><li><p>另外FIQ的入口地址是0x1c,IRQ的入口地址是0x18。写过完整汇编系统的都比较明白这点的差别，18只能放一条指令，为了不与1C处的FIQ冲突，这个地方只能跳转，而FIQ不一样，1C以后<strong>没有任何中断向量表</strong>了，这样可以直接在1C处放FIQ的中断处理程序，由于跳转的范围限制，至少<strong>少了一条跳转指令</strong>。</p></li></ol><h3 id="3-8-中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"><a href="#3-8-中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？" class="headerlink" title="3.8 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"></a>3.8 中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h3><ol><li><p>中断是CPU处于<strong>被动</strong>状态下来接受设备的信号，而轮询是CPU<strong>主动</strong>去查询该设备是否有请求。</p></li><li><p>凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个<strong>频繁请求cpu</strong>的设备，或者有<strong>大量数据</strong>请求的网络设备，那么<strong>轮询的效率是比中断高</strong>。如果是一般设备，并且该设备请求cpu的频率比较低，则用<strong>中断效率要高一些</strong>。主要是看<strong>请求频率</strong>。</p></li></ol><h2 id="4-通信协议"><a href="#4-通信协议" class="headerlink" title="4.通信协议"></a>4.通信协议</h2><h3 id="4-1-什么是异步传输和同步传输？"><a href="#4-1-什么是异步传输和同步传输？" class="headerlink" title="4.1 什么是异步传输和同步传输？"></a>4.1 什么是异步传输和同步传输？</h3><p><strong>异步传输</strong>：是一种典型的基于字节的输入输出，数据按每次<strong>一个字节</strong>进行传输，其传输<strong>速度低</strong>。</p><p><strong>同步传输</strong>：需要外界的<strong>时钟信号</strong>进行通信，是把数据字节组合起来一起发送，这种组合称之为帧，其传输速度比异步传输<strong>快</strong>。</p><h3 id="4-2-RS232和RS485通讯接口有什么区别？"><a href="#4-2-RS232和RS485通讯接口有什么区别？" class="headerlink" title="4.2 RS232和RS485通讯接口有什么区别？"></a>4.2 RS232和RS485通讯接口有什么区别？</h3><ol><li><p><strong>传输方式不同</strong>。RS232采取不平衡传输方式，即所谓<strong>单端通讯</strong>。而RS485则采用平衡传输，即<strong>差分传输</strong>方式。</p></li><li><p><strong>传输距离不同</strong>。RS232适合本地设备之间的通信，传输距离一般<strong>不超过20m</strong>。而RS485的传输距离为<strong>几十米到上千米</strong>。</p></li><li><p><strong>设备数量</strong>。RS232只允许<strong>一对一</strong>通信，而RS485接口在总线上是允许连接<strong>多达128个收发器</strong>。</p></li><li><p><strong>连接方式</strong>。RS232，规定用<strong>电平</strong>表示数据，因此线路就是单线路的，用<strong>两根线才能达到全双工</strong>的目的；而RS485，使用<strong>差分电平</strong>表示数据，因此，必须用<strong>两根线</strong>才能达到传输数据的基本要求，要实现<strong>全双工</strong>，必需用<strong>4根线</strong>。</p></li></ol><p><strong>总结</strong>：从某种意义上，可以说，线路上存在的仅仅是电流，<strong>RS232/RS485规定了这些电流在什么样的线路上流动和流动的样式</strong>。</p><h3 id="4-3-SPI协议"><a href="#4-3-SPI协议" class="headerlink" title="4.3 SPI协议"></a>4.3 SPI协议</h3><p>SPI的应用</p><p>SPI(Serial Peripheral Interface)协议是由摩托罗拉公司提出的通讯协议，即<strong>串行外围设备接口</strong>，是一种<strong>高速全双工</strong>的通信总线。SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。SPI总线可直接与各个厂家生产的多种标准外围器件相连，包括FLASH、RAM、网络控制器、LCD显示驱动器、A/D转换器和MCU等。</p><h3 id="4-4-接口"><a href="#4-4-接口" class="headerlink" title="4.4 接口"></a>4.4 接口</h3><ol><li><p><strong>MOSI(MasterOutput，SlaveInput)</strong></p><p> 主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。</p></li><li><p><strong>MISO(MasterInput,，SlaveOutput)</strong></p><p> 主设备输入/从设备输出引脚。主机从这条信号线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。</p></li><li><p><strong>SCLK(SerialClock)</strong></p><p> 时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如STM32的SPI时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。</p></li><li><p><strong>SS(SlaveSelect)</strong></p><p> 从设备选择信号线，常称为片选信号线，也称为NSS、CS，以下用NSS表示。当有多个SPI从设备与SPI主机相连时，设备的其它信号线SCK、MOSI及MISO同时并联到相同的SPI总线上，即无论有多少个从设备，都共同只使用这3条总线；而每个从设备都有独立的这一条NSS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。I2C协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而SPI协议中没有设备地址，它使用NSS信号线来寻址，当主机要选择从设备时，把该从设备的NSS信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行SPI通讯。所以SPI通讯以NSS线置低电平为开始信号，以NSS线被拉高作为结束信号。</p></li></ol><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_.png"></p><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_21f31a802aea8fa8.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_21f31a802aea8fa8.png"></p><ol><li><p><strong>通讯的起始和停止信号</strong></p><p> 在图中的标号1处，NSS信号线<strong>由高变低，是SPI通讯的起始信号</strong>。NSS是每个从机各自独占的信号线，当从机检在自己的NSS线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，<strong>NSS信号由低变高，是SPI通讯的停止信号</strong>，表示本次通讯结束，从机的选中状态被取消。</p></li><li><p><strong>数据有效性</strong></p><p> SPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时，MSB先行（高位先行）或LSB（低位先行）先行并没有作硬性规定，但要保证两个SPI通讯设备之间使用同样的协定，一般都会采用上图中的MSB先行（高位先行）模式。观察图中的2345标号处，<strong>MOSI及MISO的数据在SCK的上升沿期间变化输出，在SCK的下降沿时被采样</strong>。即在<strong>SCK的下降沿时刻，MOSI及MISO的数据有效</strong>，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI及MISO为下一次表示数据做准备。SPI每次数据传输可以8位或16位为单位，每次传输的单位数不受限制。</p></li><li><p><strong>CPOL（时钟极性）/CPHA（时钟相位）及通讯模式</strong></p><p> 上面讲述的图中的时序只是SPI中的其中一种通讯模式，SPI一共有四种通讯模式，它们的主要区别是：总线空闲时SCK的时钟状态以及数据采样时刻。为方便说明，在此引入“时钟极性CPOL”和“时钟相位CPHA”的概念。</p><blockquote><p>时钟极性CPOL是指SPI通讯设备处于空闲状态时，SCK信号线的电平信号(即SPI通讯开始前、NSS线为高电平时SCK的状态)。CPOL=0时，SCK在空闲状态时为低电平，CPOL=1时，则相反。</p></blockquote></li></ol><p>时钟相位CPHA是指数据的采样的时刻，当CPHA=0时，MOSI或MISO数据线上的信号将会在SCK时钟线的“奇数边沿”被采样。当CPHA=1时，数据线在SCK的“偶数边沿”采样。</p><h3 id="4-4-IIC协议"><a href="#4-4-IIC协议" class="headerlink" title="4.4 IIC协议"></a>4.4 IIC协议</h3><p><strong>简介</strong></p><ol><li><p>IIC协议是由<strong>数据线SDA和时钟SCL</strong>构成的串行总线，可发送和接收数据,是一个多主机的<strong>半双工</strong>通信方式</p></li><li><p>每个挂接在总线上的器件都有个<strong>唯一的地址</strong>。位速在标准模式下可达 100kbit/s，在快速模式下可达400kbit/s，在高速模式下可待3.4Mbit/s。</p></li><li><p>I2C总线系统结构,如下所示:</p><p> <img src="https://tuchuang.voooe.cn/images/2023/03/18/_0e8765696e41629a.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_0e8765696e41629a.png"></p></li></ol><p><strong>时序介绍</strong></p><ol><li><p>空闲状态<br>当总线上的SDA和SCL<strong>两条信号线同时处于高电平，便是空闲状态</strong>，如上面的硬件图所示，当我们不传输数据时，SDA和SCL被上拉电阻拉高，即进入空闲状态</p></li><li><p>起始信号<br>当<strong>时钟线SCL为高期间，数据线SDA由高到低(下降沿)的跳变；便是总线的启动</strong>信号，只能由<strong>主机</strong>发起，且在空闲状态下才能启动该信号，如下图所示：</p></li></ol><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_02de16c30bdfa26e.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_02de16c30bdfa26e.png"></p><p><strong>停止信号</strong></p><ul><li>当<strong>SCL为高期间，SDA由低到高(上升沿)的跳变；便是总线的停止</strong>信号,表示数据已传输完成，如下图所示：</li></ul><blockquote><p>总结：时钟线SCL与数据线SDA、半双工、空闲时两线高电平、起始与停止SCL均为高电平(SDa下降沿开始、上升沿结束)</p></blockquote><p><strong>传输数据格式</strong><br>当发了起始信号后,就开始传输数据,传输的数据格式如下图所示：</p><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_d78c7db3a8a0f5d7.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_d78c7db3a8a0f5d7.png"></p><ol><li><p>当<strong>SCL为高电平时，便会获取SDA数据</strong>，其中SDA数据必须是<strong>稳定</strong>的(若SDA不稳定就会变成起始/停止信<br>号)。</p></li><li><p>当SCL为<strong>低电平</strong>时，便是SDA的电平<strong>变化</strong>状态。</p></li><li><p>若主从机在传输数据期间，需要完成其它功能(例如一个<strong>中断</strong>)，可以<strong>主动拉低SCL</strong>，使I2C进入<strong>等待</strong>(不读取)状态，直到处理结束再释放SCL，数据传输会继续。</p></li></ol><p><strong>应答信号ACK</strong></p><ul><li><p>I2C总线上的数据都是以<strong>8位数据(一个字节</strong>)进行的，当发送了8个数据后，发送方会在<strong>第9个时钟脉冲期间</strong>释放SDA数据，当接收方接收该字节成功，便会输出一个ACK应答信号，当SDA为高电平，表示为非应答信号NACK，当<strong>SDA为低电平，表示为有效应答信号ACK</strong>(记住是接收方发送ACK信号)</p></li><li><p>PS:当主机为接收方时，收到<strong>最后</strong>一个字节后，主机可以不发送ACK，直接发送<strong>停止信号</strong>来结束传输。</p></li><li><p>当从机为接收方时，没有发送ACK，则表示从机可能在忙其它事、或者不匹配地址信号和不支持多主机发送，主机可以发送停止信号，再次发送起始信号<strong>启动新的传输</strong>。</p></li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_632beb8c0c138d38.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_632beb8c0c138d38.png"></p><p><strong>完整的数据传输</strong></p><ul><li><p>如下图所示，发送起始信号后，便发送一个<strong>8位的设备地址</strong>，其中<strong>第8位是对设备的读写标志</strong>，后面紧跟着的就是数据了，直到发送停止信号终止。</p></li><li><p>PS:当我们第一次是读操作，然后想换成写操作时，可以<strong>再次发送一个起始信号</strong>，然后发送读的设备地址，不需要停止信号便能实现<strong>不同的地址转换</strong>。</p></li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_0c443cec30276300.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_0c443cec30276300.png"></p><p><strong>IIC传输数据的格式</strong></p><ul><li><p><strong>写操作</strong></p><p>  刚开始主芯片要发出一个<strong>start信号</strong>，然后发出一个(用来确定是往哪一个芯片写数据，即器件地址)，<strong>方向</strong>(读/写，0表示写，1表示读)。回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个<strong>回应</strong>信号（确定数据是否接受完成)，然后再传输下一个数据。<strong>每传输一个数据，接受方都会有一个回应信号</strong>，数据发送完之后，主芯片就会发送一个停止信号。<br>白色：主→从 | 灰色：从→主。</p></li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_7b444066e8987422.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_7b444066e8987422.png"></p><ul><li><strong>读操作</strong><br>刚开始主芯片要发出一个<strong>start信号</strong>，然后发出一个<strong>设备地址</strong>(用来确定是从哪一个芯片读取数据)，方向(读/写，0表示写，1表示读)。回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后在传输下一个数据。<strong>每传输一个数据，接受方都会有一个回应信号</strong>，数据发送完之后，主芯片就会发送一个停止信号。<br>白色：主→从 | 灰色：从→主</li></ul><p><img src="https://tuchuang.voooe.cn/images/2023/03/18/_fad840b315ab024c.png" alt="https://tuchuang.voooe.cn/images/2023/03/18/_fad840b315ab024c.png"></p><blockquote><p>注意灰色与白色的不同，其实搞清楚读那个就是只要发送开始信号和回应即可</p></blockquote><h2 id="5-编程"><a href="#5-编程" class="headerlink" title="5.编程"></a>5.编程</h2><p><strong>嵌人式编程中，什么是大端？什么是小端？</strong><br>大端模式：低位字节存在高地址上，高位字节存在低地址上。<br>小端模式：高位字节存在高地址上，低位字节存在低地址上。</p><p><img src="https://tuchuang.voooe.cn/images/2023/03/19/_.png" alt="https://tuchuang.voooe.cn/images/2023/03/19/_.png"></p><p>STM32属于小端模式，简单的说，比如<code>u32 temp=0X12345678</code>；假设temp地址在0X2000 0010。那么内存里面,存放就变成了：</p><p>PLAINTEXT</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>因为是16进制的，一个数为0.5字节，所以 12 代表一个字节 34 代表一个字节。<br>釆用小端模式的CPU对操作数的存放方式是从低字节到高字节，而大端模式对操作数的存放方式是从高字节到低字节。例如，16位宽的数<code>0x1234</code>在小端模式CPU内存中的存放方式（假设从地址<code>0x4000</code>开始存放）见表1，而在大端模式CPU内存中的存放方式见表2。</p><p>表1：0x1234在小端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x34</td></tr><tr><td>0x4001</td><td>0x12</td></tr></tbody></table></div><p>表2：0x1234在大端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x12</td></tr><tr><td>0x4001</td><td>0x34</td></tr></tbody></table></div><p>32位宽的数<code>0x12345678</code>在小端模式CPU内存中的存放方式（假设从地址0x4000开始存放）见表3，而在大端模式CPU内存中的存放方式见表4。</p><p>表3：0x12345678在小端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x78</td></tr><tr><td>0x4001</td><td>0x56</td></tr><tr><td>0x4002</td><td>0x34</td></tr><tr><td>0x4003</td><td>0x12</td></tr></tbody></table></div><p>表4：0x12345678在大端CPU内存中的存放方式</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x12</td></tr><tr><td>0x4001</td><td>0x34</td></tr><tr><td>0x4002</td><td>0x56</td></tr><tr><td>0x4003</td><td>0x78</td></tr></tbody></table></div><p>以下程序为例：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>程序的输出结果为 50。<br>上例中，<code>sizeof(test)=2</code>，上例的声明方式是把一个 short（也就是一块16位内存）分成3部分，各部分的大小分别是4位、5位、7位，赋值语句<code>i*(short*)&amp;test）</code>就是把上面的16位内存转换成 short类型进行解释。<br>变量a的二进制表示为0000000000000010，取其低四位是<code>0010</code>.变量b的二进制表示为0000000000000011，取其低五位是<code>00011</code>。变量c的二进制表示为0000000000000000，取其低七位是<code>0000000</code>。<br><strong>80x86机是小端（修改分区表时要注意）模式，单片机一般为大端模式</strong>。小端一般是低位字节在高位字节的前面，也就是低位在内存地址低的一端，可以这样记（小端→低位→在前→与正常逻辑顺序相反），所以合成后得到<code>0000000000110010</code>，即十进制的50。<br>下面给出另外一个例子</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>小端模式是低地址存放低字节，高地址存放高字节，结构如下所示：</p><p>78 //低地址<br>56<br>34<br>12 //高地址</p><p>在内存里面测试机是小端，地址由小到大。</p><p>val1:78563412<br>val2:12345678</p><p>结果如下：</p><p>7856<br>3412</p><p><strong>如何判断计算机处理器是大端，还是小端？</strong></p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>编者的处理器为Intel处理器，因为Intel处理器一般都是小端模式，所以此时程序的输出结果为：小端<br>上述代码中，如果处理器是大端，则返回0；如果处理器是小端，则返回1。联合体 union的存放顺序是所有成员都从低地址开始存放，如果能够通过改代码知道CPU对内存是采用小端模式读写，还是采用大端模式读写，一定会令面试官刮目相看。<br>还可以通过指针地址来判断，由于在32位计算机系统中， short占两个字节，char占1个字节，所以可以采用如下做法实现该判断。</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>char类型转换会截取低位地址的值，因此如果低位存放的是22，那么说明低位地址存放低位数据，因此说明就是小端存储，即程序输出的结果为：小端</p><p><strong>如何进行大小端的转换？</strong></p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>如何对绝对地址0x100000赋值？</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p><p>首先要将0x100000强制转换成函数指针,即：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>然后再调用它：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>用typedef可以看得更直观些：</p><p>C</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git全面教程——简介！！！</title>
      <link href="/2023/08/27/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/08/27/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-git%E6%95%99%E7%A8%8B-git%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>Git是什么？</p><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><p>Git有什么特点？简单来说就是：高端大气上档次！</p><p>那什么是版本控制系统？</p><p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：</p><p>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitjianjie1.jpg" alt="1"></p><p>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。</p><p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p><p>更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。</p><p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p><p>这个软件用起来就应该像这个样子，能记录每次文件的改动：</p><div class="table-container"><table><thead><tr><th>版本</th><th>文件名</th><th>用户</th><th>说明</th><th>日期</th></tr></thead><tbody><tr><td>1</td><td>service.doc</td><td>张三</td><td>删除了软件服务条款5</td><td>7/12 10:38</td></tr><tr><td>2</td><td>service.doc</td><td>张三</td><td>增加了License人数限制</td><td>7/12 18:09</td></tr><tr><td>3</td><td>service.doc</td><td>李四</td><td>财务部门调整了合同金额</td><td>7/13 9:51</td></tr><tr><td>4</td><td>service.doc</td><td>张三</td><td>延长了免费升级周期</td><td>7/14 15:17</td></tr></tbody></table></div><p>这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。</p><h1 id="git的诞生"><a href="#git的诞生" class="headerlink" title="git的诞生"></a>git的诞生</h1><p>  很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><h1 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h1><p>Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p><p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitjianjie2.jpg" alt="2"></p><p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p><p>那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitjianjie3.jpg" alt="3"></p><p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p><p>CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p><p>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p><p>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p><p>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p><p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p><h2 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h2><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &#x27;git&#x27; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p><p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p><h2 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h2><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/">http://brew.sh/</a>。</p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitjianjie4.jpg" alt="4"></p><p>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p><h2 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h2><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p><img src="https://cdn.jsdelivr.net/gh//ahoilcming/tu/picture/gitjianjie5.jpg" alt="5"></p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p><p>第二步，通过<code>git init</code>命令把这个目录变成GitGit可以管理的仓库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p><strong>使用Windows的童鞋要特别注意：</strong></p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="https://code.visualstudio.com/">Visual Studio Code</a>代替记事本，不但功能强大，而且免费！</p><p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p><strong>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</strong></p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><h3 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a><strong>疑难解答</strong></h3><p><strong>Q：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。</strong></p><p><strong>A：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</strong></p><p><strong>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec &#39;readme.txt&#39; did not match any files</code>。</strong></p><p><strong>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>现在总结一下今天学的两点内容：</strong></p><p><strong>初始化一个Git仓库，使用<code>git init</code>命令。</strong></p><p><strong>添加文件到Git仓库，分两步：</strong></p><ol><li><p><strong>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</strong></p></li><li><p><strong>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习技能 </category>
          
          <category> git全面教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git全面教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first</title>
      <link href="/2023/08/26/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-jineng/"/>
      <url>/2023/08/26/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD-jineng/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>posts</title>
      <link href="/2023/08/25/%E5%90%8E%E7%AB%AF-houduan/"/>
      <url>/2023/08/25/%E5%90%8E%E7%AB%AF-houduan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><!-- GitCalendar容器 --></h1><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  @font-face {    /* 为载入的字体取名字(随意) */    font-family: 'YSHST';    /* 字体文件地址(相对或者绝对路径都可以) */    src: url(/font/优设好身体.woff2);    /* 定义加粗样式(加粗多少) */    font-weight: normal;    /* 定义字体样式(斜体/非斜体) */    font-style: normal;    /* 定义显示样式 */    font-display: block;  }/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {  left: -125px;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px var(rgb(179, 71, 241)) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px var(rgb(179, 71, 241)) !important;}/* 闪烁变动颜色连续渐变 */#site-name,#site-title,#site-subtitle,#post-info,.author-info__name,.author-info__description {  transition: text-shadow 1s linear !important;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: rgb(57, 134, 197);  border-radius: 8px;  opacity: 0.25;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}#cursor.hidden {  opacity: 0;}#cursor.hover {  opacity: 0.1;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}#cursor.active {  opacity: 0.5;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}:root {  --trans-light: rgba(255, 255, 255, 0.75);  --trans-dark: rgba(25, 25, 25, 0.88);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.min.css"/>
      <url>/css/runtime.min.css</url>
      
        <content type="html"><![CDATA[div#runtime{width:180px;margin:auto;color:#fff;padding-inline:5px;border-radius:10px;background-color:rgba(0,0,0,.7)}#workboard{font-size:12px}[data-theme=dark] div#runtime{color:#28b4c8;box-shadow:0 0 5px rgba(28,69,218,.71);animation:flashlight 1s linear infinite alternate}#ghbdages .github-badge img{height:20px}@-moz-keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}@-webkit-keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}@-o-keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}@keyframes flashlight{from{box-shadow:0 0 5px #1478d2}to{box-shadow:0 0 2px #1478d2}}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {                    }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){var t=new Date("08/24/2023 00:00:00");now.setTime(now.getTime()+250);var e=(now-t)/1e3/60/60/24,a=Math.floor(e),n=(now-t)/1e3/60/60-24*a,r=Math.floor(n);1==String(r).length&&(r="0"+r);var s=(now-t)/1e3/60-1440*a-60*r,i=Math.floor(s);1==String(i).length&&(i="0"+i);var o=(now-t)/1e3-86400*a-3600*r-60*i,l=Math.round(o);1==String(l).length&&(l="0"+l);let g="";g=r<18&&r>=9?`<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-上班摸鱼中.svg' title='距离月入25k也就还差一个大佬带我~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`:`<img class='boardsign' src='https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-下班啦.svg' title='下班了就该开开心心的玩耍，嘿嘿~'><span class='textTip'> <br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=g)}setInterval((()=>{createtime()}),250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
